<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zfd&#39;s blog.</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zfd.github.io/"/>
  <updated>2018-05-22T09:48:48.000Z</updated>
  <id>https://zfd.github.io/</id>
  
  <author>
    <name>zfd</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软链接、硬链接</title>
    <link href="https://zfd.github.io/2018/05/03/linux/%E8%BD%AF%E9%93%BE%E6%8E%A5%E3%80%81%E7%A1%AC%E9%93%BE%E6%8E%A5/"/>
    <id>https://zfd.github.io/2018/05/03/linux/软链接、硬链接/</id>
    <published>2018-05-02T17:51:22.000Z</published>
    <updated>2018-05-22T09:48:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>文件：元数据+用户数据；</li><li>元数据：文件名、文件创建时间、大小等；</li><li>inode：包含文件的部分元数据，是文件的唯一标识；</li></ul><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="title">fileName</span> -&gt;</span> <span class="function"><span class="title">inode</span> -&gt;</span> <span class="keyword">data</span> blocks</span><br><span class="line">                   |</span><br><span class="line">        元数据      |    用户数据</span><br><span class="line">                   |</span><br></pre></td></tr></table></figure><h2 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h2><p>solf link -&gt; inode 1 -&gt; data blocks -&gt; fileName -&gt; inode -&gt; data blocks</p><h2 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h2><p>hard link -&gt; inode -&gt; data blocks</p><p>fileName -&gt; inode -&gt; data blocks</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;文件：元数据+用户数据；&lt;/li&gt;
&lt;li&gt;元数据：文件名、文件创建时间、大小等；&lt;/li&gt;
&lt;li&gt;inode：包含文件的部分
      
    
    </summary>
    
      <category term="linux" scheme="https://zfd.github.io/categories/linux/"/>
    
    
      <category term="link" scheme="https://zfd.github.io/tags/link/"/>
    
  </entry>
  
  <entry>
    <title>http、https</title>
    <link href="https://zfd.github.io/2018/05/02/web/http%E3%80%81https/"/>
    <id>https://zfd.github.io/2018/05/02/web/http、https/</id>
    <published>2018-05-01T16:01:41.000Z</published>
    <updated>2018-05-22T09:48:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><blockquote><p>面向连接，可靠的，基于字节流的传输层协议。</p></blockquote><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><ul><li>源端口，目的端口：16位+16位（共4字节，4bytes则4*8=32位）</li><li>序列号：32位</li><li>确认号：32位</li><li>首部长度（4位）+保留（6位）+6个标志位（URG\ACK\PSH\PST\SYN\FIN）+窗口大小（16位）</li><li>16位检验和+16位紧急指针</li><li>选项+填充（可选，保证报文长度是32的整数倍）</li><li>数据（可选）</li></ul><p>首部：固定20个字节（上面前5行），选项为可选；数据不属于首部报文。</p><p>首部长度：1111，十进制的15，表示15*32/8=60字节，即最大长度；最小长度为20字节（没有选项、数据）。</p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><blockquote><p>SYN：同步序列号标志位，seq：序列号<br>ACK：确认序列号标志位，ack：确认号</p></blockquote><ol><li>client-&gt;server，SYN=1，seq=j，client进入syn_sent状态；</li><li>server-&gt;client，ACK=1，ack=j+1，SYN=1，seq=k，server进入syn_recv状态；</li><li>client-&gt;server，ACK=1，ack=k+1，成功建立连接。</li></ol><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><blockquote><p>双工通信，断开时，2边都要发送FIN，因为第一次FIN只表示一边断开，另一边可能还在发送数据。</p></blockquote><ol><li>client-&gt;server，FIN=1，seq=m，client进入fin_wait状态；</li><li>server-&gt;client，ACK=1，ack=m+1，server进入close_wait状态；</li><li>server-&gt;client，FIN=1，seq=n，server进入last_ack状态，client进入time_wait状态；</li><li>client-&gt;server，ACK=1，ack=n+1，完成4次挥手。</li></ol><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><blockquote><p>HyperText Transfer Protocol，超文本传输协议。</p></blockquote><h3 id="http请求"><a href="#http请求" class="headerlink" title="http请求"></a>http请求</h3><blockquote><p>CRLF：carriage-return line-feed，回车、换行，\r\n</p></blockquote><ul><li>请求行：请求方法 url 协议/版本 CRLF</li><li>请求头：key ： value CRLF（N行）</li><li>空行</li><li>请求体：get请求没有正文，post请求正文是参数；</li></ul><h3 id="http响应"><a href="#http响应" class="headerlink" title="http响应"></a>http响应</h3><ul><li>状态行：协议/版本 状态码 状态码描述 CRLF</li><li>响应头：key ： value CRLF（N行）</li><li>空行</li><li>响应体：html/json等</li></ul><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><h4 id="1XX，指定客户端的响应动作"><a href="#1XX，指定客户端的响应动作" class="headerlink" title="1XX，指定客户端的响应动作"></a>1XX，指定客户端的响应动作</h4><ul><li>100，continue，，客户端应当继续发送请求；</li><li>101，switching protocols，服务器通过Upgrade消息头通知客户端采用不同协议，下个请求将转换协议；</li></ul><h4 id="2XX，服务端成功处理了请求"><a href="#2XX，服务端成功处理了请求" class="headerlink" title="2XX，服务端成功处理了请求"></a>2XX，服务端成功处理了请求</h4><ul><li>200，ok，请求成功；</li><li>201，created，请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其URI已经随Location头信息返回；</li><li>202，accepted，服务器已接受请求，但尚未处理；</li><li>203，non-authoritative information，文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝，非权威性信息；</li><li>204，no content，服务器成功处理了请求，但没有返回任何内容；</li><li>205，reset content，没有新内容返回，但是浏览器要清除表单域；</li></ul><h4 id="3XX，重定向类"><a href="#3XX，重定向类" class="headerlink" title="3XX，重定向类"></a>3XX，重定向类</h4><ul><li>300，multiple choices/多重选择，被请求的资源可以在多个地方找到，并返回列表供选择（如有首选项，则在location中指定）；</li><li>301，moved permanently，请求永久重定向；</li><li>302，found，请求临时重定向；</li><li>304，not modified，客户端有缓存，可以直接使用；</li><li>305，use proxy，请求必须通过指定的代理才能被访问（location中指定）；</li></ul><h4 id="4XX，客户端请求错误"><a href="#4XX，客户端请求错误" class="headerlink" title="4XX，客户端请求错误"></a>4XX，客户端请求错误</h4><ul><li>400，bad request，客户端请求中有语法错误；</li><li>401，unauthorized，未授权，客户端请求需要身份验证；</li><li>403，forbidden，服务器拒绝该请求，权限不足等；</li><li>404，not found，服务器找不到该请求的任何资源；</li><li>405，method not allow，请求的方法不允许；</li></ul><h4 id="5XX，服务端错误"><a href="#5XX，服务端错误" class="headerlink" title="5XX，服务端错误"></a>5XX，服务端错误</h4><ul><li>500，internal server error，服务器错误；</li><li>501，not implemented，服务端不支持请求中要求的功能；</li><li>502，bad gateway，网关错误，如：php-fpm挂了；</li><li>503，service unavailable，服务器在维护或已过载，无法处理请求；</li><li>504，gateway timeout，网关超时；</li><li>505，http version not supported，不支持该http版本；</li></ul><h3 id="http的缺点"><a href="#http的缺点" class="headerlink" title="http的缺点"></a>http的缺点</h3><ul><li>窃听风险：黑客可以获取通信的内容；</li><li>篡改风险：黑客可以修改通信的内容；</li><li>冒充风险：黑客可以冒充他人身份参与通信；</li></ul><h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><blockquote><p>http+ssl/tls</p></blockquote><h3 id="对称加密、非对称加密"><a href="#对称加密、非对称加密" class="headerlink" title="对称加密、非对称加密"></a>对称加密、非对称加密</h3><p>对称加密效率更高，非对称加密更安全。</p><h3 id="https工作流程"><a href="#https工作流程" class="headerlink" title="https工作流程"></a>https工作流程</h3><ol><li>客户端发出https请求；</li><li>服务器返回ca证书（公钥、数字签名、相关信息等）；</li><li>客户端验证证书；</li><li>客户端生成对称秘钥（随机字符串），用公钥加密，并发送服务器；</li><li>服务器用私钥解密，得到对称秘钥，然后用对称秘钥加密请求的返回内容；</li><li>客户端用对称秘钥解密返回内容，并处理；</li><li>后续请求都用该对称秘钥加密、解密通信内容。</li></ol><h3 id="https优点"><a href="#https优点" class="headerlink" title="https优点"></a>https优点</h3><ul><li>解决窃听风险：通信内容加密；</li><li>解决篡改风险：具有校验机制，一旦被篡改，通信双方会立刻发现；</li><li>解决冒充风险：配备证书，防止身份被冒充；</li></ul><h3 id="https缺点"><a href="#https缺点" class="headerlink" title="https缺点"></a>https缺点</h3><ul><li>ssl证书费用高，增加部署、维护的工作；</li><li>https请求，握手次数增加，降低用户访问速度；</li><li>http重定向到https，增加了用户的访问耗时；</li><li>https涉及的安全算法会增加cpu资源的消耗；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;TCP&quot;&gt;&lt;a href=&quot;#TCP&quot; class=&quot;headerlink&quot; title=&quot;TCP&quot;&gt;&lt;/a&gt;TCP&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;面向连接，可靠的，基于字节流的传输层协议。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;报文格式&quot;
      
    
    </summary>
    
      <category term="web" scheme="https://zfd.github.io/categories/web/"/>
    
    
      <category term="http" scheme="https://zfd.github.io/tags/http/"/>
    
      <category term="https" scheme="https://zfd.github.io/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>mysql事务</title>
    <link href="https://zfd.github.io/2018/04/25/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1/"/>
    <id>https://zfd.github.io/2018/04/25/数据库/mysql事务/</id>
    <published>2018-04-25T09:44:17.000Z</published>
    <updated>2018-05-22T09:48:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="四个特性（ACID）"><a href="#四个特性（ACID）" class="headerlink" title="四个特性（ACID）"></a>四个特性（ACID）</h2><ul><li>原子性（atomicity）：事务包含的所有操作，要么全部成功，要么全部失败；</li><li>一致性（consistency）：事务执行前后，mysql的状态是一致的；</li><li>隔离性（isolation）：并发时，多个事务互相不干扰；</li><li>持久性（durability）：事务一旦提交，对于数据库的数据改变就是永久的。</li></ul><h2 id="开启命令"><a href="#开启命令" class="headerlink" title="开启命令"></a>开启命令</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span> // <span class="keyword">start</span> <span class="keyword">transaction</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>; // <span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>未提交读（read uncommitted）</td><td>O</td><td>O</td><td>O</td></tr><tr><td>已提交读（read committed）</td><td>X</td><td>O</td><td>O</td></tr><tr><td>可重复读（repeatable read）</td><td>X</td><td>X</td><td>O</td></tr><tr><td>可串行化（serializable）</td><td>X</td><td>X</td><td>X</td></tr></tbody></table><h3 id="脏读（dirty-read）"><a href="#脏读（dirty-read）" class="headerlink" title="脏读（dirty read）"></a>脏读（dirty read）</h3><p>事务A读取了事务B未提交的数据。</p><h3 id="不可重复读（nonRepeatable-read）"><a href="#不可重复读（nonRepeatable-read）" class="headerlink" title="不可重复读（nonRepeatable read）"></a>不可重复读（nonRepeatable read）</h3><p>一个事务中，多次查询某个数据却返回不同的值；这是由于事务A查询间隔内，另一个事务修改并提交了该数据。</p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>一个事务中，读取到了别的事务插入的数据，导致前后不一致。</p><h2 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h2><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>对一张表加锁，并发能力低下（读/写锁）。</p><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>只锁住特定行的数据，并发能力强。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//2种一致性锁定读操</span><br><span class="line"></span><br><span class="line">//共享锁</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"></span><br><span class="line">//排它锁</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><h3 id="间隙锁（GAP锁）"><a href="#间隙锁（GAP锁）" class="headerlink" title="间隙锁（GAP锁）"></a>间隙锁（GAP锁）</h3><p>使用索引对行锁两边的区间加锁，避免其他事务在这两个区间插入数据。</p><h3 id="next-key锁"><a href="#next-key锁" class="headerlink" title="next-key锁"></a>next-key锁</h3><p>就是行锁+间隙锁，用来避免幻读。</p><h3 id="多版本并发控制（MVCC）"><a href="#多版本并发控制（MVCC）" class="headerlink" title="多版本并发控制（MVCC）"></a>多版本并发控制（MVCC）</h3><p>乐观锁，通过版本号控制，最后提交检查版本号再提交事务。</p><h2 id="锁的应用"><a href="#锁的应用" class="headerlink" title="锁的应用"></a>锁的应用</h2><h3 id="避免脏读"><a href="#避免脏读" class="headerlink" title="避免脏读"></a>避免脏读</h3><p>脏读：事务A读到事务B未提交的数据；</p><p>解决：</p><ul><li>事务级别，已提交读以上，都只会读取已提交数据；</li><li>未提交读级别下，可以用select加排它锁，防止其他事务读；</li></ul><h3 id="避免不可重复读"><a href="#避免不可重复读" class="headerlink" title="避免不可重复读"></a>避免不可重复读</h3><p>不可重复读：事务中多次查询数据的值不一致。</p><p>处理：</p><ul><li>可重复读之下，使用mvcc解决，读取一个快照数据；</li><li>已提交读之上，可以对select加共享锁，防止其他事务写；</li></ul><h3 id="避免幻读"><a href="#避免幻读" class="headerlink" title="避免幻读"></a>避免幻读</h3><p>使用next-key锁（间隙锁+行锁），innodb自动加。</p><p>用法：(隔离级别：可重复读)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> xxx <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">between</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">15</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;//for <span class="keyword">update</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">commit</span>;//<span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure><ul><li>防止间隙插入新数据；</li><li>防止已有数据，更新成间隙内的数据；</li></ul><p>可串行化：是默认读加共享锁，写加排他锁，读写互斥。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;四个特性（ACID）&quot;&gt;&lt;a href=&quot;#四个特性（ACID）&quot; class=&quot;headerlink&quot; title=&quot;四个特性（ACID）&quot;&gt;&lt;/a&gt;四个特性（ACID）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;原子性（atomicity）：事务包含的所有操作，要么全部成功，
      
    
    </summary>
    
      <category term="数据库" scheme="https://zfd.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://zfd.github.io/tags/mysql/"/>
    
      <category term="acid" scheme="https://zfd.github.io/tags/acid/"/>
    
  </entry>
  
  <entry>
    <title>linux</title>
    <link href="https://zfd.github.io/2018/04/19/%E6%9C%8D%E5%8A%A1%E5%99%A8/linux/"/>
    <id>https://zfd.github.io/2018/04/19/服务器/linux/</id>
    <published>2018-04-18T22:34:46.000Z</published>
    <updated>2018-05-22T09:48:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><ul><li>权限是操作系统用来限制资源访问的机制，权限一般分为读、写、执行。</li><li>系统中每个文件都拥有特定的权限、所属用户及所属组，通过这样的机制来限制哪些用户、哪些组可以对特定的文件进行什么样的操作。</li><li>每个进程都是以某个用户的身份运行，所以进程的权限与该用户的权限一样，用户的权限越大，该进程所拥有的权限也就越大。</li></ul><table><thead><tr><th>权限</th><th>对文件的影响</th><th>对目录的影响</th></tr></thead><tbody><tr><td>r，读取</td><td>可读取文件内容</td><td>可列出目录内容</td></tr><tr><td>w，写入</td><td>可修改文件内容</td><td>可在目录创建、删除文件</td></tr><tr><td>x，执行</td><td>可作为命令执行</td><td>可访问目录内容</td></tr></tbody></table><p>注：目录必须拥有’x’权限才可查看其内容。</p><h3 id="UGO模型"><a href="#UGO模型" class="headerlink" title="UGO模型"></a>UGO模型</h3><ul><li>U，代表user，所属用户权限；</li><li>G，代表group，所属用户组权限；</li><li>O，代表other，其他用户的权限；</li></ul><h3 id="权限设置"><a href="#权限设置" class="headerlink" title="权限设置"></a>权限设置</h3><ul><li>每个文件/目录权限基于UGO设置；</li><li>权限三个一组（rwx），对应UGO分别设置；（即共有3组，9个权限）；</li></ul><p>例子：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">total 280</span><br><span class="line">drwxr-xr-x   <span class="number"> 1 </span>zfd  staff     <span class="number"> 18 </span>Feb<span class="number"> 18 </span>17:34 README.md</span><br><span class="line">drwxr-xr-x   <span class="number"> 1 </span>zfd  staff   <span class="number"> 1850 </span>Feb<span class="number"> 26 </span>20:50 _config.yml</span><br><span class="line">drwxr-xr-x   <span class="number"> 1 </span>zfd  staff    <span class="number"> 174 </span>Apr<span class="number"> 18 </span>22:34 db.json</span><br><span class="line">drwxr-xr-x <span class="number"> 321 </span>zfd  staff  <span class="number"> 10914 </span>Feb<span class="number"> 22 </span>22:01 node_modules</span><br><span class="line">drwxr-xr-x   <span class="number"> 1 </span>zfd  staff <span class="number"> 124449 </span>Feb<span class="number"> 22 </span>22:01 package-lock.json</span><br><span class="line">drwxr-xr-x   <span class="number"> 1 </span>zfd  staff    <span class="number"> 743 </span>Feb<span class="number"> 18 </span>18:06 package.json</span><br><span class="line">drwxr-xr-x  <span class="number"> 13 </span>zfd  staff    <span class="number"> 442 </span>Mar<span class="number"> 28 </span>00:43 public</span><br><span class="line">drwxr-xr-x   <span class="number"> 5 </span>zfd  staff    <span class="number"> 170 </span>Feb<span class="number"> 18 </span>17:34 scaffolds</span><br><span class="line">drwxr-xr-x   <span class="number"> 5 </span>zfd  staff    <span class="number"> 170 </span>Feb<span class="number"> 18 </span>17:34 source</span><br><span class="line">drwxr-xr-x   <span class="number"> 3 </span>zfd  staff    <span class="number"> 102 </span>Feb<span class="number"> 18 </span>17:34 themes</span><br></pre></td></tr></table></figure><p>说明：</p><table><thead><tr><th>-rw-r–r–</th><th>1</th><th>zfd</th><th>staff</th><th>18</th><th>Feb 18 17:34</th><th>README.md</th></tr></thead><tbody><tr><td>UGO模型的权限</td><td>链接数量</td><td>用户U</td><td>用户组G</td><td>大小</td><td>时间</td><td>文件/目录名</td></tr></tbody></table><p>drwxr-xr-x：</p><ul><li>第1位”d”是文件类型描述符，”d”是目录，”-“是文件；</li><li>2-4位”rwx”是U模型权限，这里表示可读、可写、可执行；</li><li>4-7位”r-x”是G模型权限，这里表示可读、不可写，可执行；</li><li>8-10位”r-x”是O模型权限，这里表示可读、不可写，可执行。</li></ul><h3 id="修改文件权限命令"><a href="#修改文件权限命令" class="headerlink" title="修改文件权限命令"></a>修改文件权限命令</h3><p>mode参数格式：</p><ul><li>u、g、o，分表代表用户、组、其他；</li><li>a，代表ugo；</li><li>+、-，代表加入或删除对应权限；</li><li>r、w、x，代表三种权限；</li><li>-R，代表递归地修改；</li></ul><p>例子：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//chmod mode fileName</span></span><br><span class="line"></span><br><span class="line">chmod u +rw test<span class="selector-class">.md</span>    给文件的所属用户添加rw权限</span><br><span class="line">chmod g -x test<span class="selector-class">.md</span>     给文件的所属组移除x权限</span><br><span class="line">chmod go +r test<span class="selector-class">.md</span>    给文件的所属组和其他用户添加r权限</span><br><span class="line">chmod <span class="selector-tag">a</span> -x test<span class="selector-class">.md</span>     给文件的所属UGO三个模型均移除x权限</span><br></pre></td></tr></table></figure><p>也支持3位8进制数值的方式修改：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//八进制</span></span><br><span class="line">r = <span class="number">4</span> (<span class="number">2</span> ^ <span class="number">2</span>)</span><br><span class="line">w = <span class="number">2</span> (<span class="number">2</span> ^ <span class="number">1</span>)</span><br><span class="line">x = <span class="number">1</span> (<span class="number">2</span> ^ <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">rw- = <span class="number">4</span> + <span class="number">2</span> + <span class="number">0</span> = <span class="number">6</span>    二进制的<span class="number">110</span></span><br><span class="line">rwx = <span class="number">4</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">7</span>    二进制的<span class="number">111</span></span><br><span class="line">r-x = <span class="number">4</span> + <span class="number">0</span> + <span class="number">1</span> = <span class="number">5</span>    二进制的<span class="number">101</span></span><br><span class="line"></span><br><span class="line">chmod <span class="number">660</span> test.md  设置 UGO 权限为 rw-rw----</span><br><span class="line">chmod <span class="number">777</span> test.md  设置 UGO 权限为 rwxrwxrwx</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;权限&quot;&gt;&lt;a href=&quot;#权限&quot; class=&quot;headerlink&quot; title=&quot;权限&quot;&gt;&lt;/a&gt;权限&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;权限是操作系统用来限制资源访问的机制，权限一般分为读、写、执行。&lt;/li&gt;
&lt;li&gt;系统中每个文件都拥有特定的权限、所属用户及所
      
    
    </summary>
    
      <category term="服务器" scheme="https://zfd.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="linux" scheme="https://zfd.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>解决问题记录</title>
    <link href="https://zfd.github.io/2018/04/19/%E7%AC%94%E8%AE%B0/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>https://zfd.github.io/2018/04/19/笔记/解决问题记录/</id>
    <published>2018-04-18T22:09:18.000Z</published>
    <updated>2018-05-22T09:48:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网站或接口相应时间长，应该怎么排查？"><a href="#网站或接口相应时间长，应该怎么排查？" class="headerlink" title="网站或接口相应时间长，应该怎么排查？"></a>网站或接口相应时间长，应该怎么排查？</h2><h3 id="引用文件问题"><a href="#引用文件问题" class="headerlink" title="引用文件问题"></a>引用文件问题</h3><p>浏览器F12，看看哪个文件时间长，可以排查有可能是css、js引用了一些被墙住的地址，一直请求不到，所以时间很久。</p><p>解决：相关地方注释掉、引用本地的。</p><h3 id="接口问题"><a href="#接口问题" class="headerlink" title="接口问题"></a>接口问题</h3><p>可以写个脚本内网访问一下接口，看看时间，时间长的就追踪到具体哪个业务慢。</p><p>解决：不是mysql问题，就业务逻辑优化；mysql问题可以找sql语句去explain一下，针对性优化；数据量大可以分表；</p><h3 id="网络问题"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h3><p>本地网络带宽；DNS解析时间等；</p><h3 id="服务器问题"><a href="#服务器问题" class="headerlink" title="服务器问题"></a>服务器问题</h3><p>查看linux服务器，cpu、io、network等状态；</p><p>解决：top、iostat、netstat、vmstat等命令；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;网站或接口相应时间长，应该怎么排查？&quot;&gt;&lt;a href=&quot;#网站或接口相应时间长，应该怎么排查？&quot; class=&quot;headerlink&quot; title=&quot;网站或接口相应时间长，应该怎么排查？&quot;&gt;&lt;/a&gt;网站或接口相应时间长，应该怎么排查？&lt;/h2&gt;&lt;h3 id=&quot;引
      
    
    </summary>
    
      <category term="笔记" scheme="https://zfd.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="node" scheme="https://zfd.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>redis集群</title>
    <link href="https://zfd.github.io/2018/04/17/%E6%9C%8D%E5%8A%A1%E5%99%A8/redis%E9%9B%86%E7%BE%A4/"/>
    <id>https://zfd.github.io/2018/04/17/服务器/redis集群/</id>
    <published>2018-04-17T13:33:16.000Z</published>
    <updated>2018-05-22T09:48:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>redis cluster：由多个服务于一个数据集合的redis实例组成的整体，redis实例分布在不同服务器。</p></blockquote><h2 id="集群特点"><a href="#集群特点" class="headerlink" title="集群特点"></a>集群特点</h2><ul><li>所有节点相互连接；</li><li>集群消息通过集群总线通信，集群总线端口为客户端端口+10000（固定值）；</li><li>节点与节点之间通过二进制协议进行通信；</li><li>客户端与节点之间通信和平常一样，通过文本协议进行；</li><li>集群节点不会代理查询；</li><li>数据按照slot存储分布在多个redis实例上；</li><li>集群节点挂掉会自动故障转移；</li><li>可以相对平滑扩容、缩容；</li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>核心结构在cluster.h中定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 集群状态，每个节点都保存着一个这样的状态，记录了它们眼中的集群的样子。</span></span><br><span class="line"><span class="comment">// 另外，虽然这个结构主要用于记录集群的属性，但是为了节约资源，</span></span><br><span class="line"><span class="comment">// 有些与节点有关的属性，比如 slots_to_keys 、 failover_auth_count </span></span><br><span class="line"><span class="comment">// 也被放到了这个结构里面。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 指向当前节点的指针</span></span><br><span class="line">    clusterNode *myself;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集群当前的状态：是在线还是下线 REDIS_CLUSTER_OK, REDIS_CLUSTER_FAIL, ...</span></span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集群节点名单（包括 myself 节点）</span></span><br><span class="line">    <span class="comment">// 字典的键为节点的名字，字典的值为 clusterNode 结构</span></span><br><span class="line">    dict *nodes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录要从当前节点迁移到目标节点的槽，以及迁移的目标节点</span></span><br><span class="line">    <span class="comment">// migrating_slots_to[i] = NULL 表示槽 i 未被迁移</span></span><br><span class="line">    <span class="comment">// migrating_slots_to[i] = clusterNode_A 表示槽 i 要从本节点迁移至节点 A</span></span><br><span class="line">    clusterNode *migrating_slots_to[REDIS_CLUSTER_SLOTS];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录要从源节点迁移到本节点的槽，以及进行迁移的源节点</span></span><br><span class="line">    <span class="comment">// importing_slots_from[i] = NULL 表示槽 i 未进行导入</span></span><br><span class="line">    <span class="comment">// importing_slots_from[i] = clusterNode_A 表示正从节点 A 中导入槽 i</span></span><br><span class="line">    clusterNode *importing_slots_from[REDIS_CLUSTER_SLOTS];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 负责处理各个槽的节点</span></span><br><span class="line">    <span class="comment">// 例如 slots[i] = clusterNode_A 表示槽 i 由节点 A 处理</span></span><br><span class="line">    clusterNode *slots[REDIS_CLUSTER_SLOTS];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳跃表，表中以槽作为分值，键作为成员，对槽进行有序排序</span></span><br><span class="line">    <span class="comment">// 当需要对某些槽进行区间（range）操作时，这个跳跃表可以提供方便</span></span><br><span class="line">    <span class="comment">// 具体操作定义在 db.c 里面</span></span><br><span class="line">    zskiplist *slots_to_keys;</span><br><span class="line">    ...</span><br><span class="line">&#125; clusterState;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点状态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 节点标识</span></span><br><span class="line">    <span class="comment">// 使用各种不同的标识值记录节点的角色（比如主节点或者从节点），</span></span><br><span class="line">    <span class="comment">// 以及节点目前所处的状态（比如在线或者下线）。</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由这个节点负责处理的槽</span></span><br><span class="line">    <span class="comment">// 一共有 REDIS_CLUSTER_SLOTS / 8 个字节长</span></span><br><span class="line">    <span class="comment">// 每个字节的每个位记录了一个槽的保存状态</span></span><br><span class="line">    <span class="comment">// 位的值为 1 表示槽正由本节点处理，值为 0 则表示槽并非本节点处理</span></span><br><span class="line">    <span class="comment">// 比如 slots[0] 的第一个位保存了槽 0 的保存情况</span></span><br><span class="line">    <span class="comment">// slots[0] 的第二个位保存了槽 1 的保存情况，以此类推</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> slots[REDIS_CLUSTER_SLOTS/<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针数组，指向各个从节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> **<span class="title">slaves</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果这是一个从节点，那么指向主节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">slaveof</span>;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// clusterLink 包含了与其他节点进行通讯所需的全部信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterLink</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// TCP 套接字描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与这个连接相关联的节点，如果没有的话就为 NULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">node</span>;</span></span><br><span class="line">    ...</span><br><span class="line">&#125; clusterLink;</span><br></pre></td></tr></table></figure><h2 id="集群通信"><a href="#集群通信" class="headerlink" title="集群通信"></a>集群通信</h2><h3 id="通信端口"><a href="#通信端口" class="headerlink" title="通信端口"></a>通信端口</h3><p>集群中每个redis实例，都会使用两个tcp端口：</p><ul><li>一个给客户端（redis-cli或应用程序等）使用；</li><li>另一个用于集群中实例相互通信的内部总线端口，此端口比第一个大10000。</li></ul><h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><blockquote><p>Redis集群采用P2P的Gossip（流言）协议，Gossip协议工作原理就是节点彼此不断通信交换信息，一段时间后所有的节点都会知道集群完整的信息，这种方式类似流言传播。</p></blockquote><ul><li>集群中每个节点通过一定规则挑选要通信的节点，每个节点可能知道全部节点，也可能仅知道部分节点，只要这些节点彼此可以正常通信，最终它们会达到一致的状态。</li><li>当节点出故障、新节点加入、主从角色变化、槽信息变更等事件发生时，通过不断的ping/pong消息通信，经过一段时间后所有的节点都会知道整个集群全部节点的最新状态，从而达到集群状态同步的目的。</li></ul><h3 id="组建集群（cluster-meet）"><a href="#组建集群（cluster-meet）" class="headerlink" title="组建集群（cluster meet）"></a>组建集群（cluster meet）</h3><blockquote><p>组建集群，把各个独立的节点链接起来，构成一个包含多个节点的集群。</p></blockquote><p>命令：cluster meet <ip> <port></port></ip></p><ol><li>客户端向节点A发送cluster meet <nodeb ip=""> <nodeb port="">命令；</nodeb></nodeb></li><li>节点A为节点B创建一个clusterNode结构，并添加到clusterState.nodes字典里面，再向节点B发送meet消息；</li><li>节点B收到meet消息，会为节点A添加一个clusterNode结构，并添加到clusterState.nodes字典里面，再向节点A返回一条pong消息；</li><li>节点A收到pong消息，再向节点B发送ping消息；</li><li>节点B收到ping消息，握手完成；</li><li>之后，节点A会将节点B的信息通过Gossip协议传播给集群中的其他节点，让其他节点也跟节点B握手；</li><li>最终，节点B会被集群中所有节点认识。</li></ol><h3 id="消息处理（clusterProcessPacket）"><a href="#消息处理（clusterProcessPacket）" class="headerlink" title="消息处理（clusterProcessPacket）"></a>消息处理（clusterProcessPacket）</h3><ul><li>更新接收消息计数器</li><li>查找发送者节点并且不是handshake节点</li><li>更新自己的epoch和slave的offset信息</li><li>处理MEET消息，使加入集群</li><li>从goosip中发现未知节点，发起handshake</li><li>对PING，MEET回复PONG</li><li>根据收到的心跳信息更新自己clusterState中的master-slave，slots信息</li><li>对FAILOVER_AUTH_REQUEST消息，检查并投票</li><li>处理FAIL，FAILOVER_AUTH_ACK，UPDATE信息</li></ul><h3 id="定时任务（clusterCron）"><a href="#定时任务（clusterCron）" class="headerlink" title="定时任务（clusterCron）"></a>定时任务（clusterCron）</h3><ul><li>对handshake节点建立Link，发送Ping或Meet</li><li>向随机几点发送Ping</li><li>如果是从查看是否需要做Failover</li><li>统计并决定是否进行slave的迁移，来平衡不同master的slave数</li><li>判断所有pfail报告数是否过半数</li></ul><h3 id="心跳数据"><a href="#心跳数据" class="headerlink" title="心跳数据"></a>心跳数据</h3><p>发送header信息：</p><ul><li>所负责的slots的信息</li><li>主从信息</li><li>ip port信息</li><li>状态信息</li></ul><p>发送其他节点gossip信息：</p><ul><li>ping_sent,pong_received</li><li>ip、port信息</li><li>状态信息</li></ul><h2 id="分区原理"><a href="#分区原理" class="headerlink" title="分区原理"></a>分区原理</h2><h3 id="槽（slot）"><a href="#槽（slot）" class="headerlink" title="槽（slot）"></a>槽（slot）</h3><ul><li>是一个虚拟的槽，总长度16384，为固定值，编号0~16383（用户可以配置）；</li><li>每个master节点负责一部分槽；</li><li>用户get/set时，先查找对应槽位，crc16(key)%16384，再查找对应节点，从而实现负载均衡。</li></ul><p>注：crc，循环冗余校验（Cyclic Redundancy Check）</p><h3 id="位序列结构"><a href="#位序列结构" class="headerlink" title="位序列结构"></a>位序列结构</h3><ul><li>每个master节点维护一个16384/8=2048个unsigned int长度的位序列，用于检查某个槽是否拥有；</li><li>还维护一个槽到集群节点的映射，长度为16384的数组，数组下标为槽编号，数组的值为集群节点，用于快速查找槽所在的节点；</li></ul><h3 id="键哈希标签原理"><a href="#键哈希标签原理" class="headerlink" title="键哈希标签原理"></a>键哈希标签原理</h3><p>将一批数据放入同一个槽中，只需要按规则生成key，redis计算时只处理花括号内字符串：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如：设置2个key为，abc&#123;userId&#125;def，ghi&#123;userId&#125;jkl</span></span><br><span class="line"></span><br><span class="line">unsigned <span class="built_in">int</span> keyHashSlot(<span class="built_in">char</span> *<span class="built_in">key</span>, <span class="built_in">int</span> keylen) &#123;</span><br><span class="line">    <span class="built_in">int</span> s, e; </span><br><span class="line">    <span class="keyword">for</span> (s = <span class="number">0</span>; s &lt; keylen; s++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">key</span>[s] == <span class="string">'&#123;'</span>) <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (s == keylen) <span class="keyword">return</span> crc16(<span class="built_in">key</span>,keylen) &amp; <span class="number">0x3FFF</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (e = s+<span class="number">1</span>; e &lt; keylen; e++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">key</span>[e] == <span class="string">'&#125;'</span>) <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (e == keylen || e == s+<span class="number">1</span>) <span class="keyword">return</span> crc16(<span class="built_in">key</span>,keylen) &amp; <span class="number">0x3FFF</span>;</span><br><span class="line">    <span class="keyword">return</span> crc16(<span class="built_in">key</span>+s+<span class="number">1</span>,e-s<span class="number">-1</span>) &amp; <span class="number">0x3FFF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="请求重定向"><a href="#请求重定向" class="headerlink" title="请求重定向"></a>请求重定向</h3><h3 id="moved错误"><a href="#moved错误" class="headerlink" title="moved错误"></a>moved错误</h3><ol><li>请求的key对应的槽不在该节点上，节点将查看自身所保存的哈希槽到节点的映射记录，返回一个moved错误；</li><li>客户端需要再次向新节点重试。</li></ol><h3 id="ask错误"><a href="#ask错误" class="headerlink" title="ask错误"></a>ask错误</h3><ol><li>请求的key对应的槽目前属于migrating状态，并且当前节点找不到这个key了，节点返回ask错误。</li><li>ask会把对应槽的importing节点返回，让客户端重试；</li><li>客户端重试，先发送asking命令，节点将为客户端设置一个一次性的标志（flag），使得客户端可以执行一次针对importing状态的槽的命令请求，然后再发送真正的命令请求；</li><li>不必更新客户端所记录的槽至节点的映射。</li></ol><h2 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h2><h2 id="通信故障"><a href="#通信故障" class="headerlink" title="通信故障"></a>通信故障</h2><p>集群中每个节点都会定期向集群中的其他节点发送ping消息，以此交换各个节点状态信息，检查各个节点状态。</p><p>节点状态：在线、怀疑下线、已下线。</p><h3 id="主节点状态fail"><a href="#主节点状态fail" class="headerlink" title="主节点状态fail"></a>主节点状态fail</h3><p>集群里面，超过半数以上的主节点都将某主节点A报告为怀疑下线，那么A将被标记为已下线，并且标记他的节点处，会向集群广播他的fail消息。</p><h4 id="多个从节点选主"><a href="#多个从节点选主" class="headerlink" title="多个从节点选主"></a>多个从节点选主</h4><p>主节点，选举方式进行</p><h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><ol><li>从下线主节点的所有从节点中选中一个从节点</li><li>被选中的从节点执行SLAVEOF NO NOE命令，成为新的主节点</li><li>新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己</li><li>新的主节点对集群进行广播PONG消息，告知其他节点已经成为新的主节点</li><li>新的主节点开始接收和处理槽相关的请求</li></ol><h3 id="集群状态fail"><a href="#集群状态fail" class="headerlink" title="集群状态fail"></a>集群状态fail</h3><ul><li>集群中任意master节点挂掉，并且该master没有slave，集群计入fail状态；</li><li>集群超过半数以上master挂掉，无论是否有slave，集群进入fail状态。 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;redis cluster：由多个服务于一个数据集合的redis实例组成的整体，redis实例分布在不同服务器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;集群特点&quot;&gt;&lt;a href=&quot;#集群特点&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="服务器" scheme="https://zfd.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="redis" scheme="https://zfd.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>树</title>
    <link href="https://zfd.github.io/2018/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    <id>https://zfd.github.io/2018/04/13/数据结构/树/</id>
    <published>2018-04-13T09:54:56.000Z</published>
    <updated>2018-05-22T09:48:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>度：指一个节点拥有子节点的个数。<br>深度：树的层数，根节点为第一层。<br>叶子节点：度为0的节点，即没有子节点的节点。</p></blockquote><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树的每一个节点，可以有N个子节点，但是每个子节点只有一个前驱节点。</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>除了子节点外，每个节点有两个分支，左右子树，每个节点最大度数为2；</p><h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p>国内定义：</p><p>一个二叉树，每一层的节点数都达到最大值。（看上去就是一个三角形）</p><p>国外定义：</p><p>一个二叉树，非叶子节点度数都是2。（要么度为0，要么度为2）</p><h2 id="平衡二叉树（二叉排序树）"><a href="#平衡二叉树（二叉排序树）" class="headerlink" title="平衡二叉树（二叉排序树）"></a>平衡二叉树（二叉排序树）</h2><p>树的左右子树高度差不超过1，空树也是平衡二叉树；左子节点比父节点小，父节点比右子节点小。</p><p>常用实现方法：红黑树、AVL等。</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>也是平衡二叉树，C++的map、set都是红黑树实现的。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>插入、删除，会用左旋、右旋维持树的平衡。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>内存排序。</p><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>属于多叉树（平衡多路查找树），用在磁盘文件组织，如数据库索引。</p><p>相比平衡二叉树，每个节点包含的关键字增多了，层级减少了，从而减少数据查找次数和复杂度。</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B树的升级版，充分利用节点空间，让查询速度更稳定，接近于二叉法查找。</p><p>B+树与B树的区别：</p><ul><li>B+树的非叶子节点，不保存关键字记录的指针，每个节点所能保存的关键字个数大大增加；</li><li>B+树的叶子节点，保存了父节点所有关键字和关键字记录的指针，每个叶子节点的关键字从小到大链接；</li><li>B+树的根节点关键字数量和其叶子节点个数相等；</li><li>B+的非叶子节点只进行数据索引，不会存实际的关键字记录的指针，所有数据地址必须要到叶子节点才能获取到，所以每次数据查询的次数都一样；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;度：指一个节点拥有子节点的个数。&lt;br&gt;深度：树的层数，根节点为第一层。&lt;br&gt;叶子节点：度为0的节点，即没有子节点的节点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;树&quot;&gt;&lt;a href=&quot;#树&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="数据结构" scheme="https://zfd.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="tree" scheme="https://zfd.github.io/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>写时复制</title>
    <link href="https://zfd.github.io/2018/04/12/%E6%A6%82%E5%BF%B5/%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6/"/>
    <id>https://zfd.github.io/2018/04/12/概念/写时复制/</id>
    <published>2018-04-12T12:19:26.000Z</published>
    <updated>2018-05-22T09:48:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>把A变量赋值给B变量时，不会立刻申请新的内存来存放B变量的值，而是通过一个计数器来公用内存；只有在其中一个引用指向变量的值发生变化时，才申请新空间保存值。<br>总结：延迟分配资源。</p></blockquote><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>只有在真正需要使用资源时才占用资源，减少资源的占用。</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ul><li>ref_count，引用计数，标记此zval被多少个变量引用，为0时被销毁；</li><li>is_ref，强制引用数，标记是否用&amp;的强制引用；</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $foo = <span class="number">1</span>; </span><br><span class="line">    xdebug_debug_zval(<span class="string">'foo'</span>); </span><br><span class="line">    $bar = $foo; </span><br><span class="line">    xdebug_debug_zval(<span class="string">'foo'</span>); </span><br><span class="line">    $bar = <span class="number">2</span>; </span><br><span class="line">    xdebug_debug_zval(<span class="string">'foo'</span>); </span><br><span class="line"><span class="meta">?&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//-----执行结果----- </span></span><br><span class="line">foo: (refcount=<span class="number">1</span>, is_ref=<span class="number">0</span>)=<span class="number">1</span> </span><br><span class="line">foo: (refcount=<span class="number">2</span>, is_ref=<span class="number">0</span>)=<span class="number">1</span> </span><br><span class="line">foo: (refcount=<span class="number">1</span>, is_ref=<span class="number">0</span>)=<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>php变量的多次赋值；</li><li>php函数的参数传递；</li><li>linux，fork进程；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;把A变量赋值给B变量时，不会立刻申请新的内存来存放B变量的值，而是通过一个计数器来公用内存；只有在其中一个引用指向
      
    
    </summary>
    
      <category term="概念" scheme="https://zfd.github.io/categories/%E6%A6%82%E5%BF%B5/"/>
    
    
      <category term="cow" scheme="https://zfd.github.io/tags/cow/"/>
    
  </entry>
  
  <entry>
    <title>mysql相关锁</title>
    <link href="https://zfd.github.io/2018/04/12/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E7%9B%B8%E5%85%B3%E9%94%81/"/>
    <id>https://zfd.github.io/2018/04/12/数据库/mysql相关锁/</id>
    <published>2018-04-11T23:02:59.000Z</published>
    <updated>2018-05-22T09:48:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><ul><li>乐观地认为数据没有别处修改，在完成业务的时候再拿锁（其实不会上锁，只是判断有无修改）。</li><li>mysql没有提供具体乐观锁，是要程序自己实现。</li></ul><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><p>用version字段（主要用这个），或时间戳字段：</p><ul><li>select data as old_data， version as old_version from … where …；</li><li>处理data、version；</li><li>update set date = new_data，version = new_version where version = old_version。</li><li>updated row &gt; 0，则成功提交事务；否则回滚。</li></ul><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><ul><li>悲观地认为数据会被别处修改，因此先确保获取锁成功再进行业务操作。（一锁二查三更新）</li><li>表锁、行锁、共享锁、排它锁，都是悲观锁，都是操作前先上锁。</li><li>mysql提供这种机制，直接用就行。</li></ul><h3 id="跟乐观锁开销比较"><a href="#跟乐观锁开销比较" class="headerlink" title="跟乐观锁开销比较"></a>跟乐观锁开销比较</h3><ul><li>取锁成功情况下，乐观锁开销较小；</li><li>取锁失败情况下，需要回滚，则乐观锁开销较大。</li></ul><p>总结：写操作少时，用乐观锁；写操作多时，用悲观锁。</p><h3 id="表锁、行锁"><a href="#表锁、行锁" class="headerlink" title="表锁、行锁"></a>表锁、行锁</h3><ul><li>表锁锁定整个表，开销小，加锁快；不会出现死锁；锁定力度大，锁冲突概率高，并发度低；</li><li>行锁锁定若干行，开销大，加锁慢；会出现死锁；锁定力度小，锁冲突概率低，并发度高。</li></ul><h3 id="共享锁、排他锁、自旋锁"><a href="#共享锁、排他锁、自旋锁" class="headerlink" title="共享锁、排他锁、自旋锁"></a>共享锁、排他锁、自旋锁</h3><ul><li>共享锁：又叫读锁，加锁后，其他线程可读，不可写；</li><li>排它锁：又叫写锁，加锁后，其他线程不可读、不可写；</li><li>自旋锁：跟排它锁类似，但不会引起调用者睡眠。</li></ul><h4 id="排他锁、自旋锁，比较"><a href="#排他锁、自旋锁，比较" class="headerlink" title="排他锁、自旋锁，比较"></a>排他锁、自旋锁，比较</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><ul><li>排它锁：线程-&gt;sleep（加锁）-&gt;running（解锁），过程有上下文切换，cpu抢占，信号量发送等；</li><li>自旋锁：线程-&gt;running（加锁-&gt;解锁），死循环检测锁的标志位。</li></ul><h5 id="开销"><a href="#开销" class="headerlink" title="开销"></a>开销</h5><p>初始开销，排它锁较高；但时间越长，排它锁不变，自旋锁线性增长。</p><h5 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h5><ul><li>互斥锁，适用于临界区锁时间较长的操作：临界区有IO操作，临界区竞争激烈，单核处理器等；</li><li>自旋锁，适用于临界区锁时间非常短，且CPU资源不紧张，一般用于多核的服务器。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;乐观锁&quot;&gt;&lt;a href=&quot;#乐观锁&quot; class=&quot;headerlink&quot; title=&quot;乐观锁&quot;&gt;&lt;/a&gt;乐观锁&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;乐观地认为数据没有别处修改，在完成业务的时候再拿锁（其实不会上锁，只是判断有无修改）。&lt;/li&gt;
&lt;li&gt;mysql没有
      
    
    </summary>
    
      <category term="数据库" scheme="https://zfd.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://zfd.github.io/tags/mysql/"/>
    
      <category term="lock" scheme="https://zfd.github.io/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>堆内存、栈内存</title>
    <link href="https://zfd.github.io/2018/04/12/%E6%A6%82%E5%BF%B5/%E5%A0%86%E5%86%85%E5%AD%98%E3%80%81%E6%A0%88%E5%86%85%E5%AD%98/"/>
    <id>https://zfd.github.io/2018/04/12/概念/堆内存、栈内存/</id>
    <published>2018-04-11T22:31:33.000Z</published>
    <updated>2018-05-22T09:48:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进出顺序"><a href="#进出顺序" class="headerlink" title="进出顺序"></a>进出顺序</h2><p>堆：顺序随意</p><p>栈：先进后出</p><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>堆：程序员手动分配，程序不释放，可能在程序结束后由系统回收，如：new，malloc；</p><p>栈：编译器自动分配、释放，速度快，存放函数的参数值，局部变量值等；</p><p>全局区（静态区）：全局变量、静态变量总是放一块的，初始化时放在同一块区域，未初始化时放在相邻的另一块区域，程序结束由系统释放；</p><p>常量区：放常量，程序结束由系统释放；</p><p>程序代码区：存放函数体的二进制代码，处理器会到这个区域取值并执行；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;进出顺序&quot;&gt;&lt;a href=&quot;#进出顺序&quot; class=&quot;headerlink&quot; title=&quot;进出顺序&quot;&gt;&lt;/a&gt;进出顺序&lt;/h2&gt;&lt;p&gt;堆：顺序随意&lt;/p&gt;
&lt;p&gt;栈：先进后出&lt;/p&gt;
&lt;h2 id=&quot;内存分配&quot;&gt;&lt;a href=&quot;#内存分配&quot; class=&quot;
      
    
    </summary>
    
      <category term="概念" scheme="https://zfd.github.io/categories/%E6%A6%82%E5%BF%B5/"/>
    
    
      <category term="heap" scheme="https://zfd.github.io/tags/heap/"/>
    
      <category term="stack" scheme="https://zfd.github.io/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>分库、分区、分表、集群</title>
    <link href="https://zfd.github.io/2018/04/11/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%86%E5%BA%93%E3%80%81%E5%88%86%E5%8C%BA%E3%80%81%E5%88%86%E8%A1%A8%E3%80%81%E9%9B%86%E7%BE%A4/"/>
    <id>https://zfd.github.io/2018/04/11/数据库/分库、分区、分表、集群/</id>
    <published>2018-04-10T21:58:45.000Z</published>
    <updated>2018-05-22T09:48:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h2><blockquote><p>分库：把一些不同业务的表放到不同数据库，不同数据库还可以放到不同的服务器。</p></blockquote><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>减轻服务器的压力，增加数据库吞吐量。</p><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><blockquote><p>分区：mysql的一种技术设计，将一个表的数据分段在同一个服务器的多个物理位置存放。</p></blockquote><p>表还是一个表，sql没有影响，业务层不用改。</p><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>减轻数据库的负担，提高数据库效率，提高表的增删改查效率。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>表数据量大，访问量不大。</p><h3 id="分区方式"><a href="#分区方式" class="headerlink" title="分区方式"></a>分区方式</h3><ul><li>range，范围</li><li>list，预定义列表</li><li>hash</li><li>key，hash模式的一种延伸</li><li>composite，复合模式，以上模式组合使用</li></ul><h3 id="sql语句"><a href="#sql语句" class="headerlink" title="sql语句"></a>sql语句</h3><p>range：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create table range(   </span><br><span class="line">  id int(11),   </span><br><span class="line">  money int(11) unsigned not null,   </span><br><span class="line">  date datetime</span><br><span class="line">)partition by range(year(date))(   </span><br><span class="line">partition p2007 values less than (2008),   </span><br><span class="line">partition p2008 values less than (2009),   </span><br><span class="line">partition p2009 values less than (2010),  </span><br><span class="line">partition p2010 values less than maxvalue   </span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h2><blockquote><p>分表：开发人员的物理设计，将一个大表按照一定规则分解成多张子表。</p></blockquote><p>表拆分成多个表，sql有影响，业务层需要调整。</p><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>减轻数据库的负担，提高数据库效率，提高表的增删改查效率。</p><h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><p>表数据量大，访问量大。</p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><blockquote><p>mysql集群是一个无共享的、分布式节点架构的存储方案，其目的是提供容错性和高性能。</p></blockquote><p>通过多个mysql服务器分配负载，从而最大程序地达到高性能，通过在不同位置存储数据保证高可用性和冗余。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>高可用性；</li><li>快速自动失效切换；</li><li>灵活分布式体系结构，没有单点故障；</li><li>高吞吐量、低延迟；</li><li>可拓展性强，支持在线扩容。</li></ul><p>缺点：</p><ul><li>不支持外键；</li><li>部署、管理、配置复杂；</li><li>占用磁盘空间大、内存大；</li><li>备份、恢复不方便；</li><li>重启时，数据节点将数据load到内存需要很长时间。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分库&quot;&gt;&lt;a href=&quot;#分库&quot; class=&quot;headerlink&quot; title=&quot;分库&quot;&gt;&lt;/a&gt;分库&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;分库：把一些不同业务的表放到不同数据库，不同数据库还可以放到不同的服务器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;
      
    
    </summary>
    
      <category term="数据库" scheme="https://zfd.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://zfd.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>进程、进程控制块、进程上下文</title>
    <link href="https://zfd.github.io/2018/04/10/%E6%A6%82%E5%BF%B5/%E8%BF%9B%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>https://zfd.github.io/2018/04/10/概念/进程、进程控制块、进程上下文/</id>
    <published>2018-04-09T22:23:07.000Z</published>
    <updated>2018-05-22T09:48:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul><li>进程：程序执行的一个实例；</li><li>线程：进程中执行的每个任务；</li><li>进程是资源分配的基本概念，是调度运行的基本单位；</li><li>进程至少有一个线程；</li><li>父子进程使用进程间通信机制，进程内线程通过读取、写入数据到进程变量来通信；</li></ul><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><h2 id="进程控制块（PCB）"><a href="#进程控制块（PCB）" class="headerlink" title="进程控制块（PCB）"></a>进程控制块（PCB）</h2><blockquote><p>PCB：描述和控制进程运行的一个数据结构，是进程存在的唯一标识。</p></blockquote><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li>进程标识信息：内部标识符（供系统使用）、外部标识符（供用户进程访问）；</li><li>处理机状态：主要由处理机的各个寄存器内的信息组成；</li><li>进程调度信息：进程状态、进程优先级、事件、其他信息等；</li><li>进程控制信息：程序和数据地址，进程同步和通信机制，资源清单，链接指针；</li></ul><h2 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h2><blockquote><p>进程上下文：程序的物理实体、支持程序执行的物理环境，合称为进程上下文。</p></blockquote><p>进程是在操作系统支持下执行的，进程执行时需要操作系统为其设置相应的执行环境，如：系统堆栈、地址映像寄存器、程序计数器、打开文件表、相关通用寄存器等。</p><ul><li>上文：已经执行的指令和数据，及在寄存器堆栈中的内容。</li><li>正文：正在执行的。</li><li>下文：待执行的。</li></ul><h3 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h3><ul><li>挂起一个进程，将其上下文保存到存储区；</li><li>系统调度，选择一个新的进程，将其上下文恢复；</li><li>继续执行新的进程。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>进程上下文的切换，也就是如何使寄存器与堆栈中的数据流入流出PCB的存储区。</p><p>进程上下文的切换，涉及系统调度和分配资源，这些都比较耗费CPU时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;进程：程序执行的一个实例；&lt;/li&gt;
&lt;li&gt;线程：进程中执行的每个任务；&lt;/li&gt;
&lt;li&gt;进程是资源分配的基本概念，是调度运
      
    
    </summary>
    
      <category term="概念" scheme="https://zfd.github.io/categories/%E6%A6%82%E5%BF%B5/"/>
    
    
      <category term="process" scheme="https://zfd.github.io/tags/process/"/>
    
      <category term="thread" scheme="https://zfd.github.io/tags/thread/"/>
    
      <category term="pcb" scheme="https://zfd.github.io/tags/pcb/"/>
    
  </entry>
  
  <entry>
    <title>select、poll、epoll</title>
    <link href="https://zfd.github.io/2018/03/30/%E6%9C%8D%E5%8A%A1%E5%99%A8/select%E3%80%81poll%E3%80%81epoll/"/>
    <id>https://zfd.github.io/2018/03/30/服务器/select、poll、epoll/</id>
    <published>2018-03-30T14:39:42.000Z</published>
    <updated>2018-05-22T09:48:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="一个IO操作流程"><a href="#一个IO操作流程" class="headerlink" title="一个IO操作流程"></a>一个IO操作流程</h3><p>一个read（O）操作的2个阶段：</p><ul><li>对于socket，等待从网络收到数据，并且在数据到达后，复制数据到内核缓冲区；</li><li>从内核缓冲区复制数据到用户进程缓冲区，以便进程处理。</li></ul><h3 id="同步、异步"><a href="#同步、异步" class="headerlink" title="同步、异步"></a>同步、异步</h3><p>是一种通信机制，关注的是IO操作的结果返回方式。</p><ul><li>同步：提交请求-&gt;等待服务器回应-&gt;处理完毕，中间一直等待；</li><li>异步：提交请求-&gt;处理其他事情，服务器回应-&gt;通知回调-&gt;处理完毕。</li></ul><h3 id="阻塞、非阻塞"><a href="#阻塞、非阻塞" class="headerlink" title="阻塞、非阻塞"></a>阻塞、非阻塞</h3><p>是一种调用机制，关注的是IO操作的执行状态。</p><ul><li>阻塞：调用方等待IO操作完成后返回；</li><li>非阻塞：调用方不需要等待IO操作的完成就立即返回。</li></ul><h3 id="用户态、内核态"><a href="#用户态、内核态" class="headerlink" title="用户态、内核态"></a>用户态、内核态</h3><blockquote><p>内核态：控制计算机硬件资源，并提供上层应用程序运行的环境；<br>用户态：上层应用程序的活动空间，应用程序运行必须依赖内核提供的资源，如CPU资源、存储资源、I/O资源等。</p></blockquote><h3 id="文件描述符（file-descriptor，简称fd）"><a href="#文件描述符（file-descriptor，简称fd）" class="headerlink" title="文件描述符（file descriptor，简称fd）"></a>文件描述符（file descriptor，简称fd）</h3><blockquote><p>在Linux下面一切皆文件，fd是内核为文件所创的索引，所有I/O操作都要调用fd来执行。</p></blockquote><h3 id="回调函数（callback）"><a href="#回调函数（callback）" class="headerlink" title="回调函数（callback）"></a>回调函数（callback）</h3><blockquote><p>回调函数就是一个通过函数指针调用的函数。</p></blockquote><ul><li>定义一个回调函数；</li><li>提供函数实现的一方在初始化的时候，将回调函数的函数指针注册给调用者；</li><li>当特定的事件或条件发生的时候，调用者使用函数指针调用回调函数对事件进行处理。</li></ul><h2 id="网络通信模型"><a href="#网络通信模型" class="headerlink" title="网络通信模型"></a>网络通信模型</h2><ul><li><p>阻塞式IO</p></li><li><p>非阻塞式IO</p></li><li><p>IO多路复用</p></li><li><p>信号驱动IO</p></li><li><p>异步IO</p></li></ul><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><blockquote><p>I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。</p></blockquote><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数：</span></span><br><span class="line"><span class="comment"> * maxfdp: 待监听的最大fd数+1。</span></span><br><span class="line"><span class="comment"> * readSet：待监听的可读fd集合</span></span><br><span class="line"><span class="comment"> * writeSet：待监听的可写fd集合</span></span><br><span class="line"><span class="comment"> * exceptSet：待监听的异常fd集合</span></span><br><span class="line"><span class="comment"> * timeval：指定超时，NULL为一直等到，0为不等待</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回：</span></span><br><span class="line"><span class="comment"> * 就绪描述符的数目，超时返回0，出错返回-1，</span></span><br><span class="line"><span class="comment"> * 正常返回后，对应fd_set会设置相关满足条件的fd。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp, fd_set *readset, fd_set *writeset, fd_set *exceptset, <span class="keyword">const</span> struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//fd_set相关操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>; <span class="comment">//清空集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;<span class="comment">//将一个给定的文件描述符加入集合之中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;<span class="comment">//将一个给定的文件描述符从集合中删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;<span class="comment">//检查集合中指定的文件描述符是否可以读写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//相关结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> tv_sec;<span class="comment">//seconds</span></span><br><span class="line">    <span class="keyword">long</span> tv_usec;<span class="comment">//microseconds</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NFDBITS (8 * sizeof(unsigned long)) <span class="comment">//32位编译器，unsigned long为4个字节</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FD_SETSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FDSET_LONGS (__FD_SETSIZE/__NFDBITS)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> fds_bits [__FDSET_LONGS];</span><br><span class="line">&#125; __kernel_fd_set;</span><br></pre></td></tr></table></figure><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>单个进程监听的fd数量有限，最多为1024；（能改，但是改后影响效率）；</li><li>每次调用select，都需要遍历所有fd，才能发现哪些发生了事件，效率慢；</li><li>内存复制开销大，需要从用户空间、内核空间来回拷贝fd_set；</li></ul><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用pollfd结构而不是select的fd_set结构，其他的都差不多。</p><p>就少了select的fd数量限制，其他缺点仍存在。</p><h4 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd * fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构</span></span><br><span class="line">truct pollfd &#123;</span><br><span class="line">    <span class="keyword">int</span> fd;<span class="comment">//文件描述符</span></span><br><span class="line">    <span class="keyword">short</span> events;<span class="comment">//等待的事件</span></span><br><span class="line">    <span class="keyword">short</span> revents;<span class="comment">//实际发生了的事件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><h4 id="函数-2"><a href="#函数-2" class="headerlink" title="函数"></a>函数</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建epoll句柄，返回值为句柄，即epfd</span></span><br><span class="line">int epoll_create(int size)；</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册要监听的事件类型</span></span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待事件的发生</span></span><br><span class="line">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)；</span><br></pre></td></tr></table></figure><h4 id="解决select、poll的缺点"><a href="#解决select、poll的缺点" class="headerlink" title="解决select、poll的缺点"></a>解决select、poll的缺点</h4><ul><li>epoll_create，提前准备好相关资源（开辟内核缓冲区，创建红黑树和就绪链表），注册事件只是往里面添加新的fd，所支持的fd上限是最大可以打开文件的数目；</li><li>epoll_ctl，注册事件时，就会把fd拷贝进内核，保证每个fd只拷贝一次；</li><li>epoll_ctl，注册事件时，为每个fd指定一个回调函数，当设备就绪，唤醒队列上的等待者时，就会调用回调函数，把就绪的fd加入一个就绪链表；</li><li>epoll_wait，等待事件的发生，只需要查看就绪链表中有没有就绪的fd，并且返回的fd是通过mmap让内核和用户空间共享同一块内存实现传递的，减少了不必要的拷贝；</li></ul><h4 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h4><ul><li>LT模式（level trigger，默认模式）：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件；</li><li>ET模式（edge trigger）：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</li></ul><p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>epoll比select和poll高效的原因主要有：</p><ul><li>减少了用户态和内核态之间的fd拷贝； </li><li>减少了对就绪fd的遍历；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;相关概念&quot;&gt;&lt;a href=&quot;#相关概念&quot; class=&quot;headerlink&quot; title=&quot;相关概念&quot;&gt;&lt;/a&gt;相关概念&lt;/h2&gt;&lt;h3 id=&quot;一个IO操作流程&quot;&gt;&lt;a href=&quot;#一个IO操作流程&quot; class=&quot;headerlink&quot; title=&quot;一
      
    
    </summary>
    
      <category term="服务器" scheme="https://zfd.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="epoll" scheme="https://zfd.github.io/tags/epoll/"/>
    
      <category term="select" scheme="https://zfd.github.io/tags/select/"/>
    
      <category term="poll" scheme="https://zfd.github.io/tags/poll/"/>
    
  </entry>
  
  <entry>
    <title>简单查找算法</title>
    <link href="https://zfd.github.io/2018/03/23/%E7%AE%97%E6%B3%95/%E7%AE%80%E5%8D%95%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>https://zfd.github.io/2018/03/23/算法/简单查找算法/</id>
    <published>2018-03-22T17:45:14.000Z</published>
    <updated>2018-05-22T09:48:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h2><blockquote><p>时间复杂度：一个算法执行所耗费的时间。<br>空间复杂度：运行完一个程序所需内存的大小。</p></blockquote><table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>平均空间复杂度</th></tr></thead><tbody><tr><td>二分查找</td><td>O(log<sub>2</sub>n)</td><td>递归：O(log<sub>2</sub>n)，非递归：O(1)</td></tr></tbody></table><h2 id="二分查找（Binary-Search）"><a href="#二分查找（Binary-Search）" class="headerlink" title="二分查找（Binary Search）"></a>二分查找（Binary Search）</h2><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>首先元素队列要有序；</li><li>然后跟队列中间位置的比较，根据大小选择左或右队列，再次折半查找；</li><li>直到找到相同元素或无匹配。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>注：默认从小到大排序。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BinarySearch</span><span class="params">($arr, $intV, $intL, $intR)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ($intL &gt; $intR) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $intM = intval(($intL + $intR) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> ($intV == $arr[$intM]) &#123;</span><br><span class="line">        <span class="keyword">return</span> $intM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ($intV &lt; $arr[$intM]) &#123;</span><br><span class="line">        <span class="keyword">return</span> BinarySearch($arr, $intV, $intL, $intM - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BinarySearch($arr, $intV, $intM + <span class="number">1</span>, $intR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BinarySearch2</span><span class="params">($arr, $intV, $intL, $intR)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>($intL &lt;= $intR) &#123;</span><br><span class="line">        $intM = intval(($intL + $intR) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> ($intV == $arr[$intM]) &#123;</span><br><span class="line">            <span class="keyword">return</span> $intM;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ($intV &lt; $arr[$intM]) &#123;</span><br><span class="line">            $intR = $intM - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            $intL = $intM + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$arr = <span class="keyword">array</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>);</span><br><span class="line">$intI = BinarySearch($arr, <span class="number">2</span>, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"><span class="comment">//$intI = BinarySearch2($arr, 2, 0, 8);</span></span><br><span class="line">var_export($intI);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;算法总结&quot;&gt;&lt;a href=&quot;#算法总结&quot; class=&quot;headerlink&quot; title=&quot;算法总结&quot;&gt;&lt;/a&gt;算法总结&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;时间复杂度：一个算法执行所耗费的时间。&lt;br&gt;空间复杂度：运行完一个程序所需内存的大小。&lt;/p&gt;

      
    
    </summary>
    
      <category term="算法" scheme="https://zfd.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="php" scheme="https://zfd.github.io/tags/php/"/>
    
      <category term="search" scheme="https://zfd.github.io/tags/search/"/>
    
  </entry>
  
  <entry>
    <title>简单排序算法</title>
    <link href="https://zfd.github.io/2018/03/23/%E7%AE%97%E6%B3%95/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://zfd.github.io/2018/03/23/算法/简单排序算法/</id>
    <published>2018-03-22T17:45:08.000Z</published>
    <updated>2018-05-22T09:48:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h2><blockquote><p>时间复杂度：一个算法执行所耗费的时间。<br>空间复杂度：运行完一个程序所需内存的大小。</p></blockquote><table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>平均空间复杂度</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n<sup>2</sup>)</td><td>O(1)</td></tr><tr><td>选择排序</td><td>O(n<sup>2</sup>)</td><td>O(1)</td></tr><tr><td>插入排序</td><td>O(n<sup>2</sup>)</td><td>O(1)</td></tr><tr><td>希尔排序</td><td>O(nlog<sub>2</sub>n)</td><td>O(1)</td></tr><tr><td>归并排序</td><td>O(nlog<sub>2</sub>n)</td><td>O(n)</td></tr><tr><td>快速排序</td><td>O(nlog<sub>2</sub>n)</td><td>O(log<sub>2</sub>n)</td></tr><tr><td>堆排序</td><td>O(nlog<sub>2</sub>n)</td><td>O(1)</td></tr><tr><td>桶排序</td><td>O(n+k)</td><td>O(n+k)</td></tr></tbody></table><p>下面排序，1～n个元素，默认从小到大排列。</p><h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>比较第1个、第2个元素，如果第1个比较大，则交换2个元素的位置；</li><li>比较第2个、第3个元素，3、4，4、5，以此类推，最后得到第n个元素为最大值；</li><li>对1～n－1的剩余元素，重复1、2步骤的操作，以此类推，每一次循环后，最大的元素在右边，直到排序完成。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span><span class="params">(&amp;$arr, $intI, $intJ)</span> </span>&#123;</span><br><span class="line">    $intTmp = $arr[$intI];</span><br><span class="line">    $arr[$intI] = $arr[$intJ];</span><br><span class="line">    $arr[$intJ] = $intTmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span><span class="params">($arr)</span> </span>&#123;</span><br><span class="line">    $intN = count($arr);</span><br><span class="line">    <span class="keyword">for</span> ($intI = <span class="number">0</span>; $intI &lt; $intN; $intI++) &#123;</span><br><span class="line">        <span class="keyword">for</span> ($intJ = <span class="number">0</span>; $intJ &lt; $intN - $intI - <span class="number">1</span>; $intJ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ($arr[$intJ] &gt; $arr[$intJ + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap($arr, $intJ, $intJ + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$arr = <span class="keyword">array</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">$arr = bubbleSort($arr);</span><br><span class="line">var_export($arr);</span><br></pre></td></tr></table></figure><h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h2><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>从1～n里面，取第1个元素依次去跟其它元素比较；</li><li>如果遇到比他大的，则记录较大的元素下标i，用元素i继续去比较；</li><li>最后把i跟n交换位置，第n个元素为最大值；</li><li>从1～n－1里面，重复步骤1～3的操作，直到排序完成。</li></ol><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span><span class="params">(&amp;$arr, $intI, $intJ)</span> </span>&#123;</span><br><span class="line">    $intTmp = $arr[$intI];</span><br><span class="line">    $arr[$intI] = $arr[$intJ];</span><br><span class="line">    $arr[$intJ] = $intTmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span><span class="params">($arr)</span> </span>&#123;</span><br><span class="line">    $intN = count($arr);</span><br><span class="line">    <span class="keyword">for</span> ($intI = <span class="number">0</span>; $intI &lt; $intN; $intI++) &#123;</span><br><span class="line">        $intM = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ($intJ = <span class="number">0</span>; $intJ &lt; $intN - $intI - <span class="number">1</span>; $intJ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ($arr[$intM] &lt; $arr[$intJ + <span class="number">1</span>]) &#123;</span><br><span class="line">                $intM = $intJ + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap($arr, $intM, $intJ);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$arr = <span class="keyword">array</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">$arr = selectionSort($arr);</span><br><span class="line">var_export($arr);</span><br></pre></td></tr></table></figure><h2 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h2><h3 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>取第1个元素，默认为已排序；</li><li>从右边未排序的元素中，取第一个元素，跟已排序的元素做比较（从后往前）；</li><li>如果遇到比他大的，则交换位置，遇到比他小的或到头了，则停止；</li><li>重复1～3操作，直到排序完成。</li></ol><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span><span class="params">(&amp;$arr, $intI, $intJ)</span> </span>&#123;</span><br><span class="line">    $intTmp = $arr[$intI];</span><br><span class="line">    $arr[$intI] = $arr[$intJ];</span><br><span class="line">    $arr[$intJ] = $intTmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span><span class="params">($arr)</span> </span>&#123;</span><br><span class="line">    $intN = count($arr);</span><br><span class="line">    <span class="keyword">for</span> ($intJ = <span class="number">1</span>; $intJ &lt; $intN; $intJ++) &#123;</span><br><span class="line">        $intI = $intJ - <span class="number">1</span>;</span><br><span class="line">        $intT = $intJ;</span><br><span class="line">        <span class="keyword">while</span> ($intI &gt;= <span class="number">0</span> &amp;&amp; $arr[$intT] &lt; $arr[$intI]) &#123;</span><br><span class="line">            swap($arr, $intI, $intT);</span><br><span class="line">            $intI--;</span><br><span class="line">            $intT--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$arr = <span class="keyword">array</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">$arr = insertionSort($arr);</span><br><span class="line">var_export($arr);</span><br></pre></td></tr></table></figure><h2 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h2><h3 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>取基准：取第1个元素作为基准；</li><li>划分区：用基准元素跟其它比较，比他小的放在他左边，比他大的放在他右边；</li><li>递归：把左、右两边的元素分别递归重复步骤1、2，最后把结果合并。</li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><p>方法1：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span><span class="params">($arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">isset</span>($arr[<span class="number">1</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> $arr;</span><br><span class="line">    &#125;</span><br><span class="line">    $intPivot = $arr[<span class="number">0</span>];</span><br><span class="line">    $arrL = <span class="keyword">array</span>();</span><br><span class="line">    $arrR = <span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">for</span> ($intI = <span class="number">1</span>; $intI &lt; count($arr); $intI++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($arr[$intI] &lt; $intPivot) &#123;</span><br><span class="line">            $arrL[] = $arr[$intI];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            $arrR[] = $arr[$intI];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    $arrL = quickSort($arrL);</span><br><span class="line">    $arrL[] = $intPivot;</span><br><span class="line">    $arrR = quickSort($arrR);</span><br><span class="line">    <span class="keyword">return</span> array_merge($arrL, $arrR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$arr = <span class="keyword">array</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">$arr = quickSort($arr);</span><br><span class="line">var_export($arr);</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_quickSort</span><span class="params">(&amp;$arr, $intL, $intR)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ($intL &gt;= $intR) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    $intI = $intL;</span><br><span class="line">    $intJ = $intR;</span><br><span class="line">    $intPivot = $arr[$intI];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ($intI &lt; $intJ) &#123;</span><br><span class="line">        <span class="keyword">while</span> ($intI &lt; $intJ &amp;&amp; $intPivot &lt;= $arr[$intJ]) &#123;</span><br><span class="line">            $intJ--;</span><br><span class="line">        &#125;</span><br><span class="line">        $arr[$intI] = $arr[$intJ];</span><br><span class="line">        <span class="keyword">while</span> ($intI &lt; $intJ &amp;&amp; $intPivot &gt; $arr[$intI]) &#123;</span><br><span class="line">            $intI++;</span><br><span class="line">        &#125;</span><br><span class="line">        $arr[$intJ] = $arr[$intI];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    $arr[$intI] = $intPivot;</span><br><span class="line">    _quickSort($arr, $intL, $intI - <span class="number">1</span>);</span><br><span class="line">    _quickSort($arr, $intI + <span class="number">1</span>, $intR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span><span class="params">($arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">isset</span>($arr[<span class="number">1</span>])) &#123;</span><br><span class="line">        <span class="keyword">return</span> $arr;</span><br><span class="line">    &#125;</span><br><span class="line">    _quickSort($arr, <span class="number">0</span>, count($arr) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> $arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$arr = <span class="keyword">array</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">$arr = quickSort($arr);</span><br><span class="line">var_export($arr);</span><br></pre></td></tr></table></figure><h2 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h2><h3 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>将待排序元素，构成大顶堆（二叉树结构，顶部为最大值），此堆为初始无序区；</li><li>将堆顶第一个元素与最后一个n元素交换，得到新的无序区和有序区。</li><li>重复步骤1~2，直到无序区没有元素。</li></ol><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span><span class="params">(&amp;$arr, $intI, $intJ)</span> </span>&#123;</span><br><span class="line">    $intTmp = $arr[$intI];</span><br><span class="line">    $arr[$intI] = $arr[$intJ];</span><br><span class="line">    $arr[$intJ] = $intTmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapify</span><span class="params">(&amp;$arr, $intI, $intJ)</span> </span>&#123;</span><br><span class="line">    $intL = $intI * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    $intR = $intL + <span class="number">1</span>;</span><br><span class="line">    $intMax = $intI;</span><br><span class="line">    <span class="keyword">if</span> ($intL &lt;= $intJ &amp;&amp; $arr[$intL] &gt; $arr[$intMax]) &#123;</span><br><span class="line">        $intMax = $intL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ($intR &lt;= $intJ &amp;&amp; $arr[$intR] &gt; $arr[$intMax]) &#123;</span><br><span class="line">        $intMax = $intR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ($intI != $intMax) &#123;</span><br><span class="line">        swap($arr, $intI, $intMax);</span><br><span class="line">        heapify($arr, $intMax, $intJ);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span><span class="params">($arr)</span> </span>&#123;</span><br><span class="line">    $intJ = count($arr) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ($intJ &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> $arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ($intI = $intJ / <span class="number">2</span> - <span class="number">1</span>; $intI &gt;= <span class="number">0</span>; $intI--) &#123;</span><br><span class="line">        heapify($arr, $intI, $intJ);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ($intI = $intJ; $intI &gt;= <span class="number">1</span>; $intI--) &#123;</span><br><span class="line">        swap($arr, <span class="number">0</span>, $intI);</span><br><span class="line">        heapify($arr, <span class="number">0</span>, $intI - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$arr = <span class="keyword">array</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">$arr = heapSort($arr);</span><br><span class="line">var_export($arr);</span><br></pre></td></tr></table></figure><h2 id="桶排序（Bucket-Sort）"><a href="#桶排序（Bucket-Sort）" class="headerlink" title="桶排序（Bucket Sort）"></a>桶排序（Bucket Sort）</h2><h3 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h3><ol><li>假设待排序的一组元素分布在一个范围内，并将这一范围划分为N个子范围，也就是桶；</li><li>将待排序的一组元素，分档放入这些桶，并将桶中的元素进行排序；</li><li>将每个桶中的数据有序地合并起来。</li></ol><h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bucketSort</span><span class="params">($arr, $intMax)</span> </span>&#123;</span><br><span class="line">    $arrBucket = array_fill(<span class="number">0</span>, $intMax + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ($intI = <span class="number">0</span>; $intI &lt; count($arr); $intI++) &#123;</span><br><span class="line">        $arrBucket[$arr[$intI]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $arrSort = <span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">for</span> ($intI = <span class="number">0</span>; $intI &lt;= $intMax; $intI++) &#123;</span><br><span class="line">        <span class="keyword">for</span> ($intJ = <span class="number">1</span>; $intJ &lt;= $arrBucket[$intI]; $intJ++) &#123;</span><br><span class="line">            $arrSort[] = $intI;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $arrSort;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$arr = <span class="keyword">array</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">$arr = bucketSort($arr, <span class="number">6</span>);</span><br><span class="line">var_export($arr);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;算法总结&quot;&gt;&lt;a href=&quot;#算法总结&quot; class=&quot;headerlink&quot; title=&quot;算法总结&quot;&gt;&lt;/a&gt;算法总结&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;时间复杂度：一个算法执行所耗费的时间。&lt;br&gt;空间复杂度：运行完一个程序所需内存的大小。&lt;/p&gt;

      
    
    </summary>
    
      <category term="算法" scheme="https://zfd.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="php" scheme="https://zfd.github.io/tags/php/"/>
    
      <category term="sort" scheme="https://zfd.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>memcached、redis比较</title>
    <link href="https://zfd.github.io/2018/03/20/%E6%9C%8D%E5%8A%A1%E5%99%A8/memcached%E3%80%81redis%E6%AF%94%E8%BE%83/"/>
    <id>https://zfd.github.io/2018/03/20/服务器/memcached、redis比较/</id>
    <published>2018-03-19T17:03:13.000Z</published>
    <updated>2018-05-22T09:48:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="memcached优点"><a href="#memcached优点" class="headerlink" title="memcached优点"></a>memcached优点</h2><ul><li>存储数据量大于10w时，性能更高；</li><li>存储结构简单（key/value），对内存利用率更高；</li></ul><h2 id="redis优点"><a href="#redis优点" class="headerlink" title="redis优点"></a>redis优点</h2><ul><li>存储小数据，性能更高；</li><li>支持结构类型更丰富；</li><li>支持持久化，存储数据更安全；</li><li>支持数据备份，主从模式；</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有持久化需求或者对数据结构和处理有更高要求，选择redis；其他简单的key/value存储，选择memcache。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;memcached优点&quot;&gt;&lt;a href=&quot;#memcached优点&quot; class=&quot;headerlink&quot; title=&quot;memcached优点&quot;&gt;&lt;/a&gt;memcached优点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;存储数据量大于10w时，性能更高；&lt;/li&gt;
&lt;li&gt;存
      
    
    </summary>
    
      <category term="服务器" scheme="https://zfd.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="nosql" scheme="https://zfd.github.io/tags/nosql/"/>
    
      <category term="memcached" scheme="https://zfd.github.io/tags/memcached/"/>
    
      <category term="redis" scheme="https://zfd.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>shell命令</title>
    <link href="https://zfd.github.io/2018/03/01/linux/shell%E5%91%BD%E4%BB%A4/"/>
    <id>https://zfd.github.io/2018/03/01/linux/shell命令/</id>
    <published>2018-03-01T14:15:20.000Z</published>
    <updated>2018-05-22T09:48:48.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!bin/sh</span></span><br><span class="line"><span class="comment">#md5当前目录所有xxx.sql=&gt;xxx.sql.md5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> *</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">test</span> -f <span class="variable">$file</span></span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        fName=<span class="variable">$&#123;file%.*&#125;</span></span><br><span class="line">        fSuffix=<span class="variable">$&#123;file##*.&#125;</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">"<span class="variable">$fSuffix</span>"</span> = <span class="string">"sql"</span> ]</span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">           md5sum <span class="variable">$file</span> | cut -d <span class="string">' '</span> -f 1 &gt; <span class="string">"<span class="variable">$file</span>"</span>.md5</span><br><span class="line">        <span class="keyword">fi</span>  </span><br><span class="line">    <span class="keyword">fi</span>  </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="linux" scheme="https://zfd.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https://zfd.github.io/tags/linux/"/>
    
      <category term="shell" scheme="https://zfd.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>grep命令</title>
    <link href="https://zfd.github.io/2018/03/01/linux/grep%E5%91%BD%E4%BB%A4/"/>
    <id>https://zfd.github.io/2018/03/01/linux/grep命令/</id>
    <published>2018-03-01T14:10:38.000Z</published>
    <updated>2018-05-22T09:48:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>主要用来查文件内容。</p></blockquote><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">a 不要忽略二进制数据。</span></span><br><span class="line"><span class="ruby">-A&lt;显示列数&gt; 除了显示符合范本样式的那一行之外，并显示该行之后的内容。</span></span><br><span class="line"><span class="ruby">-b 在显示符合范本样式的那一行之外，并显示该行之前的内容。</span></span><br><span class="line"><span class="ruby">-c 计算符合范本样式的列数。</span></span><br><span class="line"><span class="ruby">-C&lt;显示列数&gt;或-&lt;显示列数&gt;  除了显示符合范本样式的那一列之外，并显示该列之前后的内容。</span></span><br><span class="line"><span class="ruby">-d&lt;进行动作&gt; 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作。</span></span><br><span class="line"><span class="ruby">-e&lt;范本样式&gt; 指定字符串作为查找文件内容的范本样式。</span></span><br><span class="line"><span class="ruby">-E 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。</span></span><br><span class="line"><span class="ruby">-f&lt;范本文件&gt; 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式。</span></span><br><span class="line"><span class="ruby">-F 将范本样式视为固定字符串的列表。</span></span><br><span class="line"><span class="ruby">-G 将范本样式视为普通的表示法来使用。</span></span><br><span class="line"><span class="ruby">-h 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。</span></span><br><span class="line"><span class="ruby">-H 在显示符合范本样式的那一列之前，标示该列的文件名称。</span></span><br><span class="line"><span class="ruby">-i 忽略字符大小写的差别。</span></span><br><span class="line"><span class="ruby">-l 列出文件内容符合指定的范本样式的文件名称。</span></span><br><span class="line"><span class="ruby">-L 列出文件内容不符合指定的范本样式的文件名称。</span></span><br><span class="line"><span class="ruby">-n 在显示符合范本样式的那一列之前，标示出该列的编号。</span></span><br><span class="line"><span class="ruby">-q 不显示任何信息。</span></span><br><span class="line"><span class="ruby">-R/-r 此参数的效果和指定“-d recurse”参数相同。</span></span><br><span class="line"><span class="ruby">-s 不显示错误信息。</span></span><br><span class="line"><span class="ruby">-v 反转查找。</span></span><br><span class="line"><span class="ruby">-w 只显示全字符合的列。</span></span><br><span class="line"><span class="ruby">-x 只显示全列符合的列。</span></span><br><span class="line"><span class="ruby">-y 此参数效果跟“-i”相同。</span></span><br><span class="line"><span class="ruby">-o 只输出文件中匹配到的部分。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;主要用来查文件内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight haml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;b
      
    
    </summary>
    
      <category term="linux" scheme="https://zfd.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https://zfd.github.io/tags/linux/"/>
    
      <category term="grep" scheme="https://zfd.github.io/tags/grep/"/>
    
  </entry>
  
  <entry>
    <title>PHP核心技术与最佳实践</title>
    <link href="https://zfd.github.io/2018/03/01/%E7%AC%94%E8%AE%B0/PHP%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://zfd.github.io/2018/03/01/笔记/PHP核心技术与最佳实践/</id>
    <published>2018-03-01T10:02:32.000Z</published>
    <updated>2018-05-22T09:48:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象的的核心概念"><a href="#面向对象的的核心概念" class="headerlink" title="面向对象的的核心概念"></a>面向对象的的核心概念</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><blockquote><p><code>面向对象</code>（OO）：是软件开发方法。<br>  <code>面向对象编程</code>（OOP）：将对象作为程序的基本单元，把程序和数据封装其中，以提高软件的重用性、灵活性和可拓展性。</p></blockquote><h3 id="序列化、反序列化"><a href="#序列化、反序列化" class="headerlink" title="序列化、反序列化"></a>序列化、反序列化</h3><blockquote><p>对象的底层实现：“属性数组”+“方法数组”。<br>  对象的序列化：把保存在内存中的对象的属性保存起来，并且可以在需要的时候还原出来。（serialize）</p></blockquote><h3 id="继承、封装、多态"><a href="#继承、封装、多态" class="headerlink" title="继承、封装、多态"></a>继承、封装、多态</h3><blockquote><p>面向对象思想的<code>三大要素</code>：继承、封装、多态。<br>  <code>作用</code>：让代码更具开放性、可扩充性，增加代码的重用性、提高软件的可维护性。</p></blockquote><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>作用：继承一个公共类，可以使用一些公有方法，提升程序的效率，减少代码的重复。</p><ul><li>用关键字extends实现继承。</li><li>子类只能继承父类的非私有属性。</li><li>子类继承父类后，相当于将父类的属性和方法copy到子类，可以直接使用$this调用该属性。</li><li>PHP只能单继承，不支持一个类继承多个类。但是一个类可以进行多层继承（即A继承于B，而C又继承于A，C通过A间接继承了B）。 </li></ul><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>作用：防止代码冗余，也可以方便代码的调用。</p><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>概念：同一个类的不同子类表现出不同的形态。（子类重写父类的方法）</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><blockquote><p>通过反射，可以找到一个对象所属的类及拥有的方法。<br>在平常开发中，用到反射的地方不多：一个是对对象进行调试，另一个是获取类的信息</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">person</span> </span>&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> $name;</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> $gender;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;name, <span class="string">" "</span>, <span class="keyword">$this</span>-&gt;gender, <span class="string">"\r\n"</span>;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span><span class="params">($name, $value)</span> </span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">echo</span> <span class="string">"Setting $name to $value \r\n"</span>;</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;$name = $value;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">($name)</span> </span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;$name)) &#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">echo</span> <span class="string">'未设置'</span>;</span></span><br><span class="line"><span class="php">            <span class="keyword">$this</span>-&gt;$name = <span class="string">"正在为你设置默认值"</span>;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;$name;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">$student = <span class="keyword">new</span> person();</span></span><br><span class="line"><span class="php">$student-&gt;name = <span class="string">'Tom'</span>;</span></span><br><span class="line"><span class="php">$student-&gt;gender = <span class="string">'male'</span>;</span></span><br><span class="line"><span class="php">$student-&gt;age = <span class="number">24</span>;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php"><span class="comment">// 获取对象属性列表</span></span></span><br><span class="line"><span class="php">$reflect = <span class="keyword">new</span> ReflectionObject($student);</span></span><br><span class="line"><span class="php">$props = $reflect-&gt;getProperties();</span></span><br><span class="line"><span class="php"><span class="keyword">foreach</span> ($props <span class="keyword">as</span> $prop) &#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">print</span> $prop-&gt;getName() . <span class="string">"\n"</span>;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php"><span class="comment">// 获取对象方法列表</span></span></span><br><span class="line"><span class="php">$m = $reflect-&gt;getMethods();</span></span><br><span class="line"><span class="php"><span class="keyword">foreach</span> ($m <span class="keyword">as</span> $prop) &#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">print</span> $prop-&gt;getName() . <span class="string">"\n"</span>;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php"><span class="comment">// 返回对象属性的关联数组</span></span></span><br><span class="line"><span class="php">var_dump(get_object_vars($student));</span></span><br><span class="line"><span class="php"><span class="comment">// 类属性</span></span></span><br><span class="line"><span class="php">var_dump(get_class_vars(get_class($student)));</span></span><br><span class="line"><span class="php"><span class="comment">// 返回由类的方法名组成的数组</span></span></span><br><span class="line"><span class="php">var_dump(get_class_methods(get_class($student)));</span></span><br><span class="line"><span class="php"><span class="comment">// 获取对象属性列表所属的类</span></span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> get_class($student);</span></span><br></pre></td></tr></table></figure><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul><li>Deprecated最低级别错误，程序继续执行</li><li>Notice 通知级别的错误 如直接使用未声明变量，程序继续执行</li><li>Warning 警告级别的错误，可能得不到想要的结果</li><li>Fatal error  致命级别错误致命级别错误，程序不往下执行</li><li>parse error 语法解析错误，最高级别错误，连其他错误信息也不呈现出来</li><li>E_USER_相关错误 用户设置的相关错误</li></ul><p>error_reporting(-1)显示所有错误，error_reporting(0)屏蔽所有错误。</p><p>error_reporting(E_ALL&amp;~E_NOTICE)不显示通知级别的错误。“~”表示非。</p><h2 id="PHP网络技术及应用"><a href="#PHP网络技术及应用" class="headerlink" title="PHP网络技术及应用"></a>PHP网络技术及应用</h2><h3 id="Web-基础"><a href="#Web-基础" class="headerlink" title="Web 基础"></a>Web 基础</h3><p>HTTP（HyperText Transfer Protocol，超文本传输协议）。<br>WWW（World Wide Web）的三种技术：HTML、HTTP、URL。<br>RFC（Request for Comments，征求修正意见书），互联网的设计文档。</p><p>URI（Uniform Resource Indentifier，统一资源标识符）<br>URL（Uniform Resource Locator，统一资源定位符）<br>URN（Uniform Resource Name，统一资源名称），例如 urn:isbn:0-486-27557-4<br>URI 包含 URL 和 URN，目前 WEB 只有 URL 比较流行，所以见到的基本都是 URL。</p><h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><blockquote><p>CRLF：Carriage-Return Line-Feed，即回车+换行，\r\n</p></blockquote><ul><li>请求行：请求方法 + URL + 协议/版本 + CRLF，之间由空格分隔 </li><li>请求头：key + “:” + value + CRLF （N行）</li><li>空行</li><li>请求正文：Get请求没有正文/Post请求正文是参数</li></ul><h3 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h3><ul><li>状态行：协议/版本 + 状态码 + 状态码描述 + CRLF，之间由空格分隔</li><li>响应头：key + “:” + value + CRLF （N行）</li><li>空行</li><li>响应正文：html/json等</li></ul><p>响应消息：<br>1xx:信息响应类，表示接收到请求并且继续处理<br>2xx:处理成功响应类，表示动作被成功接收、理解和接受<br>3xx:重定向响应类，为了完成指定的动作，必须接受进一步处理<br>4xx:客户端错误，客户请求包含语法错误或者是不能正确执行<br>5xx:服务端错误，服务器不能正确执行一个正确的请求</p><h2 id="PHP模板引擎的原理和实践"><a href="#PHP模板引擎的原理和实践" class="headerlink" title="PHP模板引擎的原理和实践"></a>PHP模板引擎的原理和实践</h2><h3 id="smarty（直接看smarty就可以了）"><a href="#smarty（直接看smarty就可以了）" class="headerlink" title="smarty（直接看smarty就可以了）"></a>smarty（直接看smarty就可以了）</h3><blockquote><p>smarty是基于PHP开发的PHP模板引擎，他提供了php逻辑与html页面的分离</p></blockquote><p>工作流程：</p><ul><li>把需要显示的变量，赋值，塞到对象的内部属性中的一个数组里 </li><li>然后编译模板，将标签解析成相应的php echo代码 </li><li>引入编译后的php文件</li></ul><p>使用步骤：</p><ul><li>Smarty是一个类，要使用的话，必须引入在进行实例化 </li><li>使用assign给模板赋值 </li><li>使用display方法（从编译到输出）</li></ul><p>优点：</p><ul><li>速度快：相对于其他模板引擎</li><li>编译型：把模板文件替换成一个HTML+PHP混合的PHP文件，当下模板没有改变，将自动转向编译文件</li><li>缓存技术：一定缓存时间内，用户最终看到的html文件缓存成一个静态的html页</li><li>插件技术：可以自定义插件</li></ul><p>缺点：</p><ul><li>编译模板，浪费时间 </li><li>要把变量再重新赋值到对象的属性中，增大了开销</li><li>不适用用实时更新，股票、天气等</li><li>不适用于小项目，小项目直接开发更快</li></ul><p>Smarty.class.php：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php"> </span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">Smarty</span>  //此类就是<span class="title">libs</span>中的<span class="title">Smarty</span>.<span class="title">class</span>.<span class="title">php</span>类</span></span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> $leftlimit=<span class="string">"&lt;&#123;"</span>;  <span class="comment">//左分隔符</span></span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> $rightlimit=<span class="string">"&#125;&gt;"</span>;<span class="comment">//右分隔符</span></span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> $attr;  <span class="comment">//存放变量信息的数组</span></span></span><br><span class="line"><span class="php">     </span></span><br><span class="line"><span class="php">     </span></span><br><span class="line"><span class="php">    <span class="comment">//注册变量</span></span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">assign</span><span class="params">($k,$v)</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;attr[$k] = $v;  <span class="comment">//向数组中添加一个值,相当于$sttr[0]="sdc123"</span></span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">     </span></span><br><span class="line"><span class="php">    <span class="comment">//显示模板</span></span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">display</span><span class="params">($name)</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="comment">//1.造模板路径</span></span></span><br><span class="line"><span class="php">        $filename = $mubanlujing.$name;</span></span><br><span class="line"><span class="php">         </span></span><br><span class="line"><span class="php">        <span class="comment">//2.获取模板内容,内容是一大串代码,(例如模板为index.html)</span></span></span><br><span class="line"><span class="php">        $str=file_get_contents($filename);</span></span><br><span class="line"><span class="php">         </span></span><br><span class="line">        /*$str里面的代吗内容</span><br><span class="line">        &lt;html&gt;</span><br><span class="line">        &lt;head&gt;</span><br><span class="line">        &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;</span><br><span class="line">        &lt;/head&gt;</span><br><span class="line">        &lt;body&gt;</span><br><span class="line">        &lt;div&gt;&#123;$aa&#125;&lt;/div&gt;</span><br><span class="line">        &lt;/body&gt;</span><br><span class="line">        &lt;/html&gt;</span><br><span class="line"><span class="php">        */</span></span><br><span class="line"><span class="php">         </span></span><br><span class="line"><span class="php">        <span class="comment">//3.用正则去匹配字符串中出现的&#123;&#125;里面的内容</span></span></span><br><span class="line"><span class="php">         </span></span><br><span class="line"><span class="php">        <span class="comment">//4.将内容读取（读取到的是数组里面的key），拿key去数组attr里面取value值</span></span></span><br><span class="line"><span class="php">         </span></span><br><span class="line">            /*$str里面的代码内容</span><br><span class="line">            &lt;html&gt;</span><br><span class="line">            &lt;head&gt;</span><br><span class="line">            &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;</span><br><span class="line">            &lt;/head&gt;</span><br><span class="line">            &lt;body&gt;</span><br><span class="line">            &lt;div&gt;&lt;?php echo $attr[key]?&gt;&lt;/div&gt;</span><br><span class="line">            &lt;/body&gt;</span><br><span class="line">            &lt;/html&gt;</span><br><span class="line"><span class="php">            */</span></span><br><span class="line"><span class="php">         </span></span><br><span class="line"><span class="php">        <span class="comment">//5.将str里面的内容保存在缓存文件里面</span></span></span><br><span class="line"><span class="php">        file_put_contents($filename,$str);<span class="comment">//$filename是新的文件</span></span></span><br><span class="line"><span class="php">         </span></span><br><span class="line"><span class="php">        <span class="comment">//6.将存储的文件加载到当前页面</span></span></span><br><span class="line"><span class="php">        <span class="keyword">include</span>(filename);</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">     </span></span><br><span class="line"><span class="php">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="缓存详解"><a href="#缓存详解" class="headerlink" title="缓存详解"></a>缓存详解</h2><blockquote><p><code>缓存</code>：凡是位于速度相差较大的两种介质之间，用于协调两者数据传输速度差异的结构。</p></blockquote><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>性能：解决高并发，大数据场景下，热点数据访问的性能问题。提供高性能的数据快速访问。(主要作用)</li><li>稳定性：一些重复请求每次都要处理，会加大服务器的资源消耗，影响系统稳定性。</li><li>可用性：提供数据的服务挂了，缓存可以在一段时间内正常提供用户支持，提高系统可用性。</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>减少计算量，缩短请求流程（网络i/o、硬盘i/o）：</p><ul><li>将数据写入/读取速度更快的存储（设备）；</li><li>将数据缓存到离应用最近的位置；</li><li>将数据缓存到离用户最近的位置。</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>理论上，web的每一层都可以被缓存。</p><ul><li>CPU缓存；</li><li>内存：Memcached这样的Key Value内存缓存；</li><li>数据库：Query cache，Table cache，Thread cache；</li><li>应用程序代码级别：Smarty文件缓存；</li><li>浏览器：浏览器缓存；</li></ul><p>注：理论上各层都可以被缓存。</p><p><code>缓存的存放位置</code>：CPU、内存、硬盘。</p><h3 id="缓存的三个要素"><a href="#缓存的三个要素" class="headerlink" title="缓存的三个要素"></a>缓存的三个要素</h3><blockquote><p>命中率，更新策略，最大数据量。</p></blockquote><h4 id="命中率"><a href="#命中率" class="headerlink" title="命中率"></a>命中率</h4><p>命中率 = 请求缓存次数 / 缓存返回正确结果，比例越高越好，比例过低可能会造成反效果。</p><h3 id="更新策略"><a href="#更新策略" class="headerlink" title="更新策略"></a>更新策略</h3><p>超出缓存最大数据量时，清理缓存的常用策略：</p><ul><li>FIFO（first in first out），先进先出；（如：mysql的query cache）</li><li>LFU（less frequently used），最少使用；</li><li>LRU（least recently used），最近最少使用；</li></ul><h3 id="最大数据量"><a href="#最大数据量" class="headerlink" title="最大数据量"></a>最大数据量</h3><p>缓存元素的最大个数 或 所能使用的最大存储空间。</p><p>超出最大数据量时，一般如下处理：</p><ul><li>停止缓存服务，所有缓存数据清空；</li><li>拒绝写入，拒绝更新；</li><li>根据缓存策略，清理旧数据（还可以备份旧数据）；</li></ul><h2 id="Memcached使用与实践"><a href="#Memcached使用与实践" class="headerlink" title="Memcached使用与实践"></a>Memcached使用与实践</h2><blockquote><p>本质上是一个key/value的内存数据库，但是不支持数据的持久化，服务器关闭之后数据全部丢失。</p></blockquote><h3 id="为什么要用memcached？"><a href="#为什么要用memcached？" class="headerlink" title="为什么要用memcached？"></a>为什么要用memcached？</h3><ul><li>对数据库的高并发读写；（关系型数据库承受不了高并发的读写，如：每秒上万次）</li><li>对海量数据的处理；（数据量上亿左右，表的读写效率低）</li></ul><h2 id="redis使用与实践"><a href="#redis使用与实践" class="headerlink" title="redis使用与实践"></a>redis使用与实践</h2><blockquote><p>本质上是一个key/value的内存数据库。</p></blockquote><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><table><thead><tr><th>结构类型</th><th>结构存储的值</th><th>结构的读写能力</th></tr></thead><tbody><tr><td>string</td><td>字符串、整形、浮点数</td><td>对字符串整个或部分操作，对整形、浮点数自增或自减</td></tr><tr><td>list</td><td>链表，每个节点都包含一个字符串</td><td>两端push、pop；根据偏移量修剪；读取单个或多个元素；根据值查找或移除元素</td></tr><tr><td>set</td><td>无序集合，包含string，并且每个字符串都是唯一</td><td>CRUD元素；与集合计算交集、并集、差集；从集合随机获取元素</td></tr><tr><td>hash</td><td>散列表，包含键值对，key/value 都是字符串类型</td><td>CRUD键值对；获取所有键值对</td></tr><tr><td>zset</td><td>有序集合，字符串成语与浮点数分值之间的有序映射，元素排序顺序由分值大小决定</td><td>CRUD元素；根据分值范围或成员获取元素</td></tr></tbody></table><h4 id="简单动态字符串（SDS）"><a href="#简单动态字符串（SDS）" class="headerlink" title="简单动态字符串（SDS）"></a>简单动态字符串（SDS）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 保存字符串对象的结构 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span>      </span><br><span class="line">    <span class="comment">// buf 中已占用空间的长度  </span></span><br><span class="line">    <span class="keyword">int</span> len;  </span><br><span class="line">    <span class="comment">// buf 中剩余可用空间的长度  </span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;  </span><br><span class="line">    <span class="comment">// 数据空间  </span></span><br><span class="line">    <span class="keyword">char</span> buf[];  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>常数复杂度获取字符串的长度：len属性保存了字符串的长度；（’\0’空字符不计入len）</li><li>杜绝缓冲区溢出：当对SDS进行修改时，先检查SDS的空间是否满足修改所需要的空间要求，如果不满足，则先扩展空间，然后执行修改操作；</li><li>减少修改字符串带来的内存重分配次数：<ul><li>空间预分配：当SDS的长度小于1MB时，分配（2 * len + 1B）的空间；当SDS的长度大于等于1MB时，分配（len + 1MB + 1B）的空间；</li><li>惰性空间释放：当缩短字符串时，并不会立即使用内存重分配来回收多出来的字符，而是记录在free属性中；</li></ul></li></ul><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 双端链表节点 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span>  </span><br><span class="line">    <span class="comment">// 前置节点  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span>  </span><br><span class="line">    <span class="comment">// 后置节点  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span>  </span><br><span class="line">    <span class="comment">// 节点的值  </span></span><br><span class="line">    <span class="keyword">void</span> *value;  </span><br><span class="line">&#125; listNode;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 双端链表结构 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span>  </span><br><span class="line">    <span class="comment">// 表头节点  </span></span><br><span class="line">    listNode *head;  </span><br><span class="line">    <span class="comment">// 表尾节点  </span></span><br><span class="line">    listNode *tail;  </span><br><span class="line">    <span class="comment">// 节点值复制函数  </span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);  </span><br><span class="line">    <span class="comment">// 节点值释放函数  </span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);  </span><br><span class="line">    <span class="comment">// 节点值对比函数  </span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);  </span><br><span class="line">    <span class="comment">// 链表所包含的节点数量  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;  </span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 字典 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span>  </span><br><span class="line">    <span class="comment">// 类型特定函数，Redis为不同用途的字典设置不同的类型特定函数  </span></span><br><span class="line">    dictType *type;  </span><br><span class="line">    <span class="comment">// 私有数据，传递给特定类型函数的可选参数  </span></span><br><span class="line">    <span class="keyword">void</span> *privdata;  </span><br><span class="line">    <span class="comment">// 哈希表，一般情况下字典使用ht[0]，ht[1]只会在对ht[0]进行rehash时使用  </span></span><br><span class="line">    dictht ht[<span class="number">2</span>];  </span><br><span class="line">    <span class="comment">// rehash 索引  </span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1  </span></span><br><span class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span>  </span><br><span class="line">    <span class="comment">// 目前正在运行的安全迭代器的数量  </span></span><br><span class="line">    <span class="keyword">int</span> iterators; <span class="comment">/* number of iterators currently running */</span>  </span><br><span class="line">&#125; dict;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 哈希表 </span></span><br><span class="line"><span class="comment"> * 每个字典都使用两个哈希表，从而实现渐进式 rehash 。 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span>      </span><br><span class="line">    <span class="comment">// 哈希表数组，存放具体的键值对  </span></span><br><span class="line">    dictEntry **table;  </span><br><span class="line">    <span class="comment">// 哈希表大小  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;      </span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值  </span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;  </span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;  </span><br><span class="line">&#125; dictht;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 哈希表节点 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span>      </span><br><span class="line">    <span class="comment">// 键  </span></span><br><span class="line">    <span class="keyword">void</span> *key;  </span><br><span class="line">    <span class="comment">// 值  </span></span><br><span class="line">    <span class="keyword">union</span> &#123;  </span><br><span class="line">        <span class="keyword">void</span> *val;  </span><br><span class="line">        <span class="keyword">uint64_t</span> u64;  </span><br><span class="line">        <span class="keyword">int64_t</span> s64;  </span><br><span class="line">    &#125; v;  </span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span>  </span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><h4 id="跳跃表（skiplist）"><a href="#跳跃表（skiplist）" class="headerlink" title="跳跃表（skiplist）"></a>跳跃表（skiplist）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 跳跃表 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span>  </span><br><span class="line">    <span class="comment">// 表头节点和表尾节点  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span>  </span><br><span class="line">    <span class="comment">// 表中节点的数量  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;  </span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数，表头结点的层数不计算在内  </span></span><br><span class="line">    <span class="keyword">int</span> level;  </span><br><span class="line">&#125; zskiplist;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 跳跃表节点 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span>  </span><br><span class="line">    <span class="comment">// 成员对象  </span></span><br><span class="line">    robj *obj;  </span><br><span class="line">    <span class="comment">// 分值，跳跃表中节点按各自所保存的分值从小到大排列  </span></span><br><span class="line">    <span class="keyword">double</span> score;  </span><br><span class="line">    <span class="comment">// 后退指针，指向当前节点的前一个节点  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span>  </span><br><span class="line">    <span class="comment">// 层，每次创建一个新节点，程序按幂次定律随机生成一个1~32的值作为level数组的大小（层高度）  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span>  </span><br><span class="line">        <span class="comment">// 前进指针  </span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span>  </span><br><span class="line">        <span class="comment">// 跨度，前进指针所指向的节点和当前节点的距离  </span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;  </span><br><span class="line">    &#125; level[];  </span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><h4 id="整数集合（intset）"><a href="#整数集合（intset）" class="headerlink" title="整数集合（intset）"></a>整数集合（intset）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span>      </span><br><span class="line">    <span class="comment">// 编码方式  </span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;  </span><br><span class="line">    <span class="comment">// 集合包含的元素数量  </span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;  </span><br><span class="line">    <span class="comment">// 保存元素的数组，各项在数组中按值大小有序地排序并且不包含重得项  </span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];  </span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><h4 id="压缩列表（ziplist）"><a href="#压缩列表（ziplist）" class="headerlink" title="压缩列表（ziplist）"></a>压缩列表（ziplist）</h4><h3 id="redis优势"><a href="#redis优势" class="headerlink" title="redis优势"></a>redis优势</h3><ul><li>Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li><li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</li></ul><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><ul><li>内存快照（snapshotting）</li></ul><p>每个一段时间进行一次内存快照，把内存中的数据写入二进制文件中（*.rdb）；save，在主进程操作，阻塞主进程，不能快速响应请求；bgsave，fork一个子进程操作，主进程继续处理请求，完成后通知主进程；</p><p>缺点：每次都是全部内存数据写入，数据量大会操作频繁，影响性能。</p><ul><li>日志追加（append only file）</li></ul><p>把增加、修改数据的命令通过write函数追加到文件尾部（*.aof）；redis重启时读取所有命令并且执行，从而把数据写入内存；</p><p>缺点：日志文件膨胀比较快，如nums自增100次，恢复只需要一次set nums 100，其他命令多余。</p><p>优化：bgrewriteaof命令，类似于内存快照方式，把命令保存到临时文件，最后再替换原来的日志文件。</p><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><table><thead><tr><th>master服务器</th><th>slave服务器</th></tr></thead><tbody><tr><td></td><td>1.连接（或重新连接）主服务器，发送同步（SYNC）命令</td></tr><tr><td>2.开始执行bgsave，生成快照文件（.rdb），然后向slave服务器发送，并使用缓冲区记录后续执行的写命令</td><td></td></tr><tr><td></td><td>3.丢弃所有旧数据，接收并载入master服务器发来的快照文件，解释并处理完毕后，正常接收命令</td></tr><tr><td>4.继续发送缓冲区记录的后续写命令；发送完毕后，每执行一个新的写命令就再发送一次</td><td></td></tr><tr><td></td><td>5.接收并执行每一个写命令</td></tr></tbody></table><h2 id="hash算法及数据库实现"><a href="#hash算法及数据库实现" class="headerlink" title="hash算法及数据库实现"></a>hash算法及数据库实现</h2><blockquote><p>把任意长度的输入，通过hash算法变成固定长度的输出，输出的值就是hash的值。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面向对象的的核心概念&quot;&gt;&lt;a href=&quot;#面向对象的的核心概念&quot; class=&quot;headerlink&quot; title=&quot;面向对象的的核心概念&quot;&gt;&lt;/a&gt;面向对象的的核心概念&lt;/h2&gt;&lt;h3 id=&quot;面向对象&quot;&gt;&lt;a href=&quot;#面向对象&quot; class=&quot;head
      
    
    </summary>
    
      <category term="笔记" scheme="https://zfd.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="php" scheme="https://zfd.github.io/tags/php/"/>
    
      <category term="note" scheme="https://zfd.github.io/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://zfd.github.io/2018/02/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://zfd.github.io/2018/02/25/设计模式/设计模式/</id>
    <published>2018-02-24T16:42:42.000Z</published>
    <updated>2018-05-22T09:48:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>设计模式的理解：代码设计经验的总结。<br>设计模式的作用：降低代码耦合度，提高代码重用性、可读性、可靠性。</p></blockquote><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h3><p>在整个项目中创建唯一对象实例。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>如：数据库连接。</p><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><ul><li>$_instance必须声明为静态的私有变量。</li><li>构造函数和析构函数必须声明为私有，防止外部程序new。</li><li>私有的__clone()方法防止克隆对象。</li><li>getInstance()方法必须设置为公有的，必须调用此方法以返回实例的一个引用。</li></ul><h3 id="代码demo"><a href="#代码demo" class="headerlink" title="代码demo"></a>代码demo</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php"> </span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">private</span> <span class="keyword">static</span> $instance;</span></span><br><span class="line"><span class="php">    </span></span><br><span class="line"><span class="php">    <span class="comment">//私有构造方法，禁止使用new创建对象</span></span></span><br><span class="line"><span class="php">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;&#125;</span></span><br><span class="line"><span class="php">    </span></span><br><span class="line"><span class="php">    <span class="comment">//私有析构方法</span></span></span><br><span class="line"><span class="php">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span> </span>&#123;&#125;</span></span><br><span class="line"><span class="php">    </span></span><br><span class="line"><span class="php">    <span class="comment">//将克隆方法设为私有，禁止克隆对象</span></span></span><br><span class="line"><span class="php">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__clone</span><span class="params">()</span> </span>&#123;&#125;</span></span><br><span class="line"><span class="php">        </span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="keyword">self</span>::$instance)) &#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">self</span>::$instance = <span class="keyword">new</span> <span class="keyword">self</span>;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">        <span class="keyword">return</span> <span class="keyword">self</span>::$instance;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">    </span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">echo</span> <span class="string">"这是用单例模式创建对象实例\n"</span>;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">    </span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">echo</span> <span class="string">"这里可以添加其他方法和操作\n"</span>;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">$objSingle = Singleton::getInstance();</span></span><br><span class="line"><span class="php">$objSingle-&gt;say();</span></span><br><span class="line"><span class="php">$objSingle-&gt;operation();</span></span><br><span class="line"><span class="php"> </span></span><br><span class="line"><span class="php">$objSingleNew = Singleton::getInstance();</span></span><br><span class="line"><span class="php">var_dump($shiyanlou === $objSingleNew);</span></span><br></pre></td></tr></table></figure><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>外界仅需要使用这个对象即可，不必关系创建。</li><li>避免改变某个类的名字或者方法之后，在调用这个类的所有的代码中都修改它的名字或者参数。</li></ul><p>缺点：</p><ul><li>产品类不断增多的时候，工厂类的条件判断逻辑增多，不利于维护、拓展。</li></ul><h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>工厂类负责创建的对象比较少。</li><li>客户只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心。</li><li>由于简单工厂很容易违反高内聚责任分配原则，因此一般只在很简单的情况下应用。</li></ul><h3 id="实现方法-1"><a href="#实现方法-1" class="headerlink" title="实现方法"></a>实现方法</h3><ul><li>工厂方法或者类生成对象，而不是在代码中直接new。 </li></ul><h3 id="代码demo-1"><a href="#代码demo-1" class="headerlink" title="代码demo"></a>代码demo</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span> </span></span><br><span class="line"><span class="php"><span class="comment">//简单工厂模式</span></span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">echo</span> <span class="string">"I am Cat class &lt;br&gt;"</span>;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="php">      <span class="keyword">echo</span> <span class="string">"I am Dog class &lt;br&gt;"</span>;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">CreateAnimal</span><span class="params">($name)</span></span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">if</span> ($name == <span class="string">'cat'</span>) &#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">        <span class="keyword">elseif</span> ($name == <span class="string">'dog'</span>) &#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">$cat = Factory::CreateAnimal(<span class="string">'cat'</span>);</span></span><br><span class="line"><span class="php">$dog = Factory::CreateAnimal(<span class="string">'dog'</span>);</span></span><br></pre></td></tr></table></figure><h2 id="注册模式"><a href="#注册模式" class="headerlink" title="注册模式"></a>注册模式</h2><h3 id="主要作用-1"><a href="#主要作用-1" class="headerlink" title="主要作用"></a>主要作用</h3><p>解决全局共享和交换对象。</p><h3 id="实现方法-2"><a href="#实现方法-2" class="headerlink" title="实现方法"></a>实现方法</h3><ul><li>将对象注册到全局静态变量。</li><li>任何地方直接去访问。</li></ul><h3 id="代码demo-2"><a href="#代码demo-2" class="headerlink" title="代码demo"></a>代码demo</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">Register</span> </span>&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">protected</span> <span class="keyword">static</span> $objects;</span></span><br><span class="line"><span class="php">    </span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span><span class="params">($alias,$object)</span> </span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">self</span>::$objects[$alias] = $object;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">    </span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">($name)</span> </span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">return</span> <span class="keyword">self</span>::$objects[$name];</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">    </span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">_unset</span><span class="params">($alias)</span> </span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">unset</span>(<span class="keyword">self</span>::$objects[$alias]);</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><blockquote><p>区别于策略模式，不改变已有类的方法，通过一套接口把已有类的方法统一成一样的api。<br>选择了一个适配器就从头用到尾，中途不能更改。</p></blockquote><h3 id="主要作用-2"><a href="#主要作用-2" class="headerlink" title="主要作用"></a>主要作用</h3><p>将一个类的接口适配成用户所期待的。</p><h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><p>想使用一个已经存在的类，但是他的接口并不符合要求。<br>如：</p><ul><li>PHP中的数据库操作有MySQL，MySQLi，PDO三种，可以用适配器模式统一成一致，使不同的数据库操作，统一成一样的API。</li><li>可以将memcache,redis等不同的缓存函数适配成统一的API。 </li></ul><h3 id="实现方法-3"><a href="#实现方法-3" class="headerlink" title="实现方法"></a>实现方法</h3><ul><li>首先定义一个接口（有几个方法，以及相应的参数）。</li><li>有几种不同的情况，就写几个类实现该接口。</li></ul><h3 id="代码demo-3"><a href="#代码demo-3" class="headerlink" title="代码demo"></a>代码demo</h3><p>接口</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IDatabase</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">IMooc</span>;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IDatabase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">connect</span><span class="params">($host, $user, $passwd, $dbname)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">query</span><span class="params">($sql)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适配器类（实现目标接口）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">MySQL</span><br><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php"><span class="keyword">namespace</span> <span class="title">IMooc</span>\<span class="title">Database</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">use</span> <span class="title">IMooc</span>\<span class="title">IDatabase</span>;</span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">MySQL</span> <span class="keyword">implements</span> <span class="title">IDatabase</span> </span>&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">protected</span> $conn;</span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">connect</span><span class="params">($host, $user, $passwd, $dbname)</span> </span>&#123;</span></span><br><span class="line"><span class="php">        $conn = mysql_connect($host, $user, $passwd);</span></span><br><span class="line"><span class="php">        mysql_select_db($dbname, $conn);</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;conn = $conn;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">query</span><span class="params">($sql)</span> </span>&#123;</span></span><br><span class="line"><span class="php">        $res = mysql_query($sql, <span class="keyword">$this</span>-&gt;conn);</span></span><br><span class="line"><span class="php">        <span class="keyword">return</span> $res;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="php">        mysql_close(<span class="keyword">$this</span>-&gt;conn);</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">MySQLi</span></span><br><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php"><span class="keyword">namespace</span> <span class="title">IMooc</span>\<span class="title">Database</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">use</span> <span class="title">IMooc</span>\<span class="title">IDatabase</span>;</span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">MySQLi</span> <span class="keyword">implements</span> <span class="title">IDatabase</span> </span>&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">protected</span> $conn;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">connect</span><span class="params">($host, $user, $passwd, $dbname)</span> </span>&#123;</span></span><br><span class="line"><span class="php">        $conn = mysqli_connect($host, $user, $passwd, $dbname);</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;conn = $conn;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">query</span><span class="params">($sql)</span>  </span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">return</span> mysqli_query(<span class="keyword">$this</span>-&gt;conn, $sql);</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">close</span><span class="params">()</span>  </span>&#123;</span></span><br><span class="line"><span class="php">        mysqli_close(<span class="keyword">$this</span>-&gt;conn);</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">PDO</span></span><br><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php"><span class="keyword">namespace</span> <span class="title">IMooc</span>\<span class="title">Database</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">use</span> <span class="title">IMooc</span>\<span class="title">IDatabase</span>;</span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">PDO</span> <span class="keyword">implements</span> <span class="title">IDatabase</span> </span>&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">protected</span> $conn;</span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">connect</span><span class="params">($host, $user, $passwd, $dbname)</span> </span>&#123;</span></span><br><span class="line"><span class="php">        $conn = <span class="keyword">new</span> \PDO(<span class="string">"mysql:host=$host;dbname=$dbname"</span>, $user, $passwd);</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;conn = $conn;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">    </span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">query</span><span class="params">($sql)</span> </span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;conn-&gt;query($sql);</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;conn);</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IDatabase</span> mAdapter = <span class="function"><span class="keyword">new</span> <span class="title">PDO</span>();<span class="comment">//MySQL MySQLi PDO</span></span></span><br><span class="line"><span class="function"><span class="title">mAdapter</span>.<span class="title">connect</span>(...);</span></span><br></pre></td></tr></table></figure><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><blockquote><p>区别于适配模式，类的方法都是新实现的，并且可以相互替换。</p></blockquote><h3 id="主要作用-3"><a href="#主要作用-3" class="headerlink" title="主要作用"></a>主要作用</h3><p>定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。</p><h3 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>多个类只区别在表现行为不同，可以使用Strategy模式，在运行时动态选择具体要执行的行为。</li><li>需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。</li></ul><h3 id="实现方法-4"><a href="#实现方法-4" class="headerlink" title="实现方法"></a>实现方法</h3><ul><li>首先定义一个接口（有几个方法，以及相应的参数）。</li><li>有几种不同的情况，就写几个类实现该接口。</li><li>实现一个环境类，可以根据实际情况选择、切换策略。</li></ul><h3 id="代码demo-4"><a href="#代码demo-4" class="headerlink" title="代码demo"></a>代码demo</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php"></span></span><br><span class="line">/**</span><br><span class="line"> *策略模式</span><br><span class="line"> *定义一系列的算法，把每一个算法封装起来，并且使它们可相互替换。</span><br><span class="line"> *本模式使得算法可独立于使用它的客户变化</span><br><span class="line"><span class="php"> */</span></span><br><span class="line"><span class="php"></span></span><br><span class="line">/**</span><br><span class="line"> *出行旅游</span><br><span class="line"><span class="php"> */</span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">interface</span> <span class="title">TravelStrategy</span> </span>&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">travelAlgorithm</span><span class="params">()</span></span>;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line">/**</span><br><span class="line"> *具体策略类(ConcreteStrategy)</span><br><span class="line"> *1：乘坐飞机</span><br><span class="line"><span class="php"> */</span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">AirPlanelStrategy</span> <span class="keyword">implements</span> <span class="title">TravelStrategy</span> </span>&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">travelAlgorithm</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">echo</span> <span class="string">"travelbyAirPlain"</span>, <span class="string">"\n"</span>;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line">/**</span><br><span class="line"> *具体策略类(ConcreteStrategy)</span><br><span class="line"> *2：乘坐火车</span><br><span class="line"><span class="php"> */</span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">TrainStrategy</span> <span class="keyword">implements</span> <span class="title">TravelStrategy</span> </span>&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">travelAlgorithm</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">echo</span> <span class="string">"travelbyTrain"</span>, <span class="string">"\n"</span>;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line">/**</span><br><span class="line"> *具体策略类(ConcreteStrategy)</span><br><span class="line"> *3：骑自行车</span><br><span class="line"><span class="php"> */</span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">BicycleStrategy</span> <span class="keyword">implements</span> <span class="title">TravelStrategy</span> </span>&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">travelAlgorithm</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">echo</span> <span class="string">"travelbyBicycle"</span>, <span class="string">"\n"</span>;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> *环境类(Context):</span><br><span class="line"> *用一个ConcreteStrategy对象来配置。</span><br><span class="line"> *维护一个对Strategy对象的引用。可定义一个接口来让Strategy访问它的数据。</span><br><span class="line"> *算法解决类，以提供客户选择使用何种解决方案：</span><br><span class="line"><span class="php"> */</span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">PersonContext</span> </span>&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">private</span> $_strategy = <span class="keyword">null</span>;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(TravelStrategy $travel)</span> </span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;_strategy = $travel;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line">    /**</span><br><span class="line">     *旅行</span><br><span class="line"><span class="php">     */</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setTravelStrategy</span><span class="params">(TravelStrategy $travel)</span> </span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;_strategy = $travel;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line">    /**</span><br><span class="line">     *旅行</span><br><span class="line"><span class="php">     */</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">travel</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;_strategy-&gt;travelAlgorithm();</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php"><span class="comment">//乘坐火车旅行</span></span></span><br><span class="line"><span class="php">$person = <span class="keyword">new</span> PersonContext(<span class="keyword">new</span> TrainStrategy());</span></span><br><span class="line"><span class="php">$person-&gt;travel();</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php"><span class="comment">//改骑自行车</span></span></span><br><span class="line"><span class="php">$person-&gt;setTravelStrategy(<span class="keyword">new</span> BicycleStrategy());</span></span><br><span class="line"><span class="php">$person-&gt;travel();</span></span><br></pre></td></tr></table></figure><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><blockquote><p>观察者模式(Observer)，当一个对象状态发生变化时，依赖它的对象全部会收到通知，并自动更新。</p></blockquote><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：观察者和主题之间的耦合度较小；支持广播通信；</p><p>缺点：由于观察者并不知道其它观察者的存在，它可能对改变目标的最终代价一无所知。这可能会引起意外的更新。</p><h3 id="适用场景-4"><a href="#适用场景-4" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>一个事件发生后，要执行一连串更新操作。传统的编程方式，就是在事件的代码之后直接加入处理的逻辑。当更新的逻辑增多之后，代码会变得难以维护。这种方式是耦合的，侵入式的，增加新的逻辑需要修改事件的主体代码。 </li><li>观察者模式实现了低耦合，非侵入式的通知与更新机制。 </li></ul><h3 id="代码demo-5"><a href="#代码demo-5" class="headerlink" title="代码demo"></a>代码demo</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php"></span></span><br><span class="line">/**</span><br><span class="line"> * 观察者模式</span><br><span class="line"><span class="php"> */</span></span><br><span class="line"><span class="php"></span></span><br><span class="line">/**</span><br><span class="line"> * 抽象主题角色</span><br><span class="line"><span class="php"> */</span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line">    /**</span><br><span class="line">     * 增加一个新的观察者对象</span><br><span class="line">     * @param Observer $observer</span><br><span class="line"><span class="php">     */</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">attach</span><span class="params">(Observer $observer)</span></span>;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line">    /**</span><br><span class="line">     * 删除一个已注册过的观察者对象</span><br><span class="line">     * @param Observer $observer</span><br><span class="line"><span class="php">     */</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">detach</span><span class="params">(Observer $observer)</span></span>;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line">    /**</span><br><span class="line">     * 通知所有注册过的观察者对象</span><br><span class="line"><span class="php">     */</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">notifyObservers</span><span class="params">()</span></span>;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line">/**</span><br><span class="line"> * 具体主题角色</span><br><span class="line"><span class="php"> */</span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">    <span class="keyword">private</span> $_observers;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;_observers = <span class="keyword">array</span>();</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">    <span class="comment">//增加一个新的观察者对象</span></span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">attach</span><span class="params">(Observer $observer)</span> </span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">return</span> array_push(<span class="keyword">$this</span>-&gt;_observers, $observer);</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">    <span class="comment">//删除一个已注册过的观察者对象</span></span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">detach</span><span class="params">(Observer $observer)</span> </span>&#123;</span></span><br><span class="line"><span class="php">        $index = array_search($observer, <span class="keyword">$this</span>-&gt;_observers);</span></span><br><span class="line"><span class="php">        <span class="keyword">if</span> ($index === <span class="keyword">FALSE</span> || ! array_key_exists($index, <span class="keyword">$this</span>-&gt;_observers)) &#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">return</span> <span class="keyword">FALSE</span>;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">        <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;_observers[$index]);</span></span><br><span class="line"><span class="php">        <span class="keyword">return</span> <span class="keyword">TRUE</span>;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">    <span class="comment">//通知所有注册过的观察者对象</span></span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">if</span> (!is_array(<span class="keyword">$this</span>-&gt;_observers)) &#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">return</span> <span class="keyword">FALSE</span>;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">        <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;_observers <span class="keyword">as</span> $observer) &#123;</span></span><br><span class="line"><span class="php">            $observer-&gt;update();</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">        <span class="keyword">return</span> <span class="keyword">TRUE</span>;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line">/**</span><br><span class="line"> * 抽象观察者角色</span><br><span class="line"><span class="php"> */</span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line">    /**</span><br><span class="line">     * 更新方法</span><br><span class="line"><span class="php">     */</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">()</span></span>;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span></span><br><span class="line"><span class="php">    <span class="comment">//观察者的名称</span></span></span><br><span class="line"><span class="php">    <span class="keyword">private</span> $_name;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($name)</span> </span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;_name = $name;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">    <span class="comment">//更新方法</span></span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">echo</span> <span class="string">'Observer'</span>, <span class="keyword">$this</span>-&gt;_name, <span class="string">" has notified.\n"</span>;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php"><span class="comment">//实例化类：</span></span></span><br><span class="line"><span class="php">$subject = <span class="keyword">new</span> ConcreteSubject();</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php"><span class="comment">/* 添加第一个观察者 */</span></span></span><br><span class="line"><span class="php">$observer1 = <span class="keyword">new</span> ConcreteObserver(<span class="string">'Martin'</span>);</span></span><br><span class="line"><span class="php">$subject-&gt;attach($observer1);</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">"\n The First notify:\n"</span>;</span></span><br><span class="line"><span class="php">$subject-&gt;notifyObservers();</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php"><span class="comment">/* 添加第二个观察者 */</span></span></span><br><span class="line"><span class="php">$observer2 = <span class="keyword">new</span> ConcreteObserver(<span class="string">'phppan'</span>);</span></span><br><span class="line"><span class="php">$subject-&gt;attach($observer2);</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">"\n The Second notify:\n"</span>;</span></span><br><span class="line"><span class="php">$subject-&gt;notifyObservers();</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php"><span class="comment">/* 删除第一个观察者 */</span></span></span><br><span class="line"><span class="php">$subject-&gt;detach($observer1);</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">"\n The Third notify:\n"</span>;</span></span><br><span class="line"><span class="php">$subject-&gt;notifyObservers();</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;设计模式的理解：代码设计经验的总结。&lt;br&gt;设计模式的作用：降低代码耦合度，提高代码重用性、可读性、可靠性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="设计模式" scheme="https://zfd.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="php" scheme="https://zfd.github.io/tags/php/"/>
    
      <category term="设计模式" scheme="https://zfd.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>

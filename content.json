{"meta":{"title":"Zfd's blog.","subtitle":null,"description":"my blog.","author":"zfd","url":"https://zfd.github.io"},"pages":[{"title":"tags","date":"2018-01-30T18:31:52.000Z","updated":"2018-05-22T09:48:48.000Z","comments":false,"path":"tags/index.html","permalink":"https://zfd.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-01-30T18:32:02.000Z","updated":"2018-05-22T09:48:48.000Z","comments":false,"path":"categories/index.html","permalink":"https://zfd.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"软链接、硬链接","slug":"linux/软链接、硬链接","date":"2018-05-02T17:51:22.000Z","updated":"2018-05-22T09:48:48.000Z","comments":true,"path":"2018/05/03/linux/软链接、硬链接/","link":"","permalink":"https://zfd.github.io/2018/05/03/linux/软链接、硬链接/","excerpt":"","text":"概念 文件：元数据+用户数据； 元数据：文件名、文件创建时间、大小等； inode：包含文件的部分元数据，是文件的唯一标识； 12345fileName -&gt; inode -&gt; data blocks | 元数据 | 用户数据 | 软链接solf link -&gt; inode 1 -&gt; data blocks -&gt; fileName -&gt; inode -&gt; data blocks 硬链接hard link -&gt; inode -&gt; data blocks fileName -&gt; inode -&gt; data blocks","categories":[{"name":"linux","slug":"linux","permalink":"https://zfd.github.io/categories/linux/"}],"tags":[{"name":"link","slug":"link","permalink":"https://zfd.github.io/tags/link/"}]},{"title":"http、https","slug":"web/http、https","date":"2018-05-01T16:01:41.000Z","updated":"2018-05-22T09:48:48.000Z","comments":true,"path":"2018/05/02/web/http、https/","link":"","permalink":"https://zfd.github.io/2018/05/02/web/http、https/","excerpt":"","text":"TCP 面向连接，可靠的，基于字节流的传输层协议。 报文格式 源端口，目的端口：16位+16位（共4字节，4bytes则4*8=32位） 序列号：32位 确认号：32位 首部长度（4位）+保留（6位）+6个标志位（URG\\ACK\\PSH\\PST\\SYN\\FIN）+窗口大小（16位） 16位检验和+16位紧急指针 选项+填充（可选，保证报文长度是32的整数倍） 数据（可选） 首部：固定20个字节（上面前5行），选项为可选；数据不属于首部报文。 首部长度：1111，十进制的15，表示15*32/8=60字节，即最大长度；最小长度为20字节（没有选项、数据）。 三次握手 SYN：同步序列号标志位，seq：序列号ACK：确认序列号标志位，ack：确认号 client-&gt;server，SYN=1，seq=j，client进入syn_sent状态； server-&gt;client，ACK=1，ack=j+1，SYN=1，seq=k，server进入syn_recv状态； client-&gt;server，ACK=1，ack=k+1，成功建立连接。 四次挥手 双工通信，断开时，2边都要发送FIN，因为第一次FIN只表示一边断开，另一边可能还在发送数据。 client-&gt;server，FIN=1，seq=m，client进入fin_wait状态； server-&gt;client，ACK=1，ack=m+1，server进入close_wait状态； server-&gt;client，FIN=1，seq=n，server进入last_ack状态，client进入time_wait状态； client-&gt;server，ACK=1，ack=n+1，完成4次挥手。 http HyperText Transfer Protocol，超文本传输协议。 http请求 CRLF：carriage-return line-feed，回车、换行，\\r\\n 请求行：请求方法 url 协议/版本 CRLF 请求头：key ： value CRLF（N行） 空行 请求体：get请求没有正文，post请求正文是参数； http响应 状态行：协议/版本 状态码 状态码描述 CRLF 响应头：key ： value CRLF（N行） 空行 响应体：html/json等 状态码1XX，指定客户端的响应动作 100，continue，，客户端应当继续发送请求； 101，switching protocols，服务器通过Upgrade消息头通知客户端采用不同协议，下个请求将转换协议； 2XX，服务端成功处理了请求 200，ok，请求成功； 201，created，请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其URI已经随Location头信息返回； 202，accepted，服务器已接受请求，但尚未处理； 203，non-authoritative information，文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝，非权威性信息； 204，no content，服务器成功处理了请求，但没有返回任何内容； 205，reset content，没有新内容返回，但是浏览器要清除表单域； 3XX，重定向类 300，multiple choices/多重选择，被请求的资源可以在多个地方找到，并返回列表供选择（如有首选项，则在location中指定）； 301，moved permanently，请求永久重定向； 302，found，请求临时重定向； 304，not modified，客户端有缓存，可以直接使用； 305，use proxy，请求必须通过指定的代理才能被访问（location中指定）； 4XX，客户端请求错误 400，bad request，客户端请求中有语法错误； 401，unauthorized，未授权，客户端请求需要身份验证； 403，forbidden，服务器拒绝该请求，权限不足等； 404，not found，服务器找不到该请求的任何资源； 405，method not allow，请求的方法不允许； 5XX，服务端错误 500，internal server error，服务器错误； 501，not implemented，服务端不支持请求中要求的功能； 502，bad gateway，网关错误，如：php-fpm挂了； 503，service unavailable，服务器在维护或已过载，无法处理请求； 504，gateway timeout，网关超时； 505，http version not supported，不支持该http版本； http的缺点 窃听风险：黑客可以获取通信的内容； 篡改风险：黑客可以修改通信的内容； 冒充风险：黑客可以冒充他人身份参与通信； https http+ssl/tls 对称加密、非对称加密对称加密效率更高，非对称加密更安全。 https工作流程 客户端发出https请求； 服务器返回ca证书（公钥、数字签名、相关信息等）； 客户端验证证书； 客户端生成对称秘钥（随机字符串），用公钥加密，并发送服务器； 服务器用私钥解密，得到对称秘钥，然后用对称秘钥加密请求的返回内容； 客户端用对称秘钥解密返回内容，并处理； 后续请求都用该对称秘钥加密、解密通信内容。 https优点 解决窃听风险：通信内容加密； 解决篡改风险：具有校验机制，一旦被篡改，通信双方会立刻发现； 解决冒充风险：配备证书，防止身份被冒充； https缺点 ssl证书费用高，增加部署、维护的工作； https请求，握手次数增加，降低用户访问速度； http重定向到https，增加了用户的访问耗时； https涉及的安全算法会增加cpu资源的消耗；","categories":[{"name":"web","slug":"web","permalink":"https://zfd.github.io/categories/web/"}],"tags":[{"name":"http","slug":"http","permalink":"https://zfd.github.io/tags/http/"},{"name":"https","slug":"https","permalink":"https://zfd.github.io/tags/https/"}]},{"title":"mysql事务","slug":"数据库/mysql事务","date":"2018-04-25T09:44:17.000Z","updated":"2018-05-22T09:48:48.000Z","comments":true,"path":"2018/04/25/数据库/mysql事务/","link":"","permalink":"https://zfd.github.io/2018/04/25/数据库/mysql事务/","excerpt":"","text":"四个特性（ACID） 原子性（atomicity）：事务包含的所有操作，要么全部成功，要么全部失败； 一致性（consistency）：事务执行前后，mysql的状态是一致的； 隔离性（isolation）：并发时，多个事务互相不干扰； 持久性（durability）：事务一旦提交，对于数据库的数据改变就是永久的。 开启命令12345begin // start transaction...commit; // rollback; 隔离级别 隔离级别 脏读 不可重复读 幻读 未提交读（read uncommitted） O O O 已提交读（read committed） X O O 可重复读（repeatable read） X X O 可串行化（serializable） X X X 脏读（dirty read）事务A读取了事务B未提交的数据。 不可重复读（nonRepeatable read）一个事务中，多次查询某个数据却返回不同的值；这是由于事务A查询间隔内，另一个事务修改并提交了该数据。 幻读一个事务中，读取到了别的事务插入的数据，导致前后不一致。 锁类型表锁对一张表加锁，并发能力低下（读/写锁）。 行锁只锁住特定行的数据，并发能力强。 1234567//2种一致性锁定读操//共享锁select * from table where ? lock in share mode;//排它锁select * from table where ? for update; 间隙锁（GAP锁）使用索引对行锁两边的区间加锁，避免其他事务在这两个区间插入数据。 next-key锁就是行锁+间隙锁，用来避免幻读。 多版本并发控制（MVCC）乐观锁，通过版本号控制，最后提交检查版本号再提交事务。 锁的应用避免脏读脏读：事务A读到事务B未提交的数据； 解决： 事务级别，已提交读以上，都只会读取已提交数据； 未提交读级别下，可以用select加排它锁，防止其他事务读； 避免不可重复读不可重复读：事务中多次查询数据的值不一致。 处理： 可重复读之下，使用mvcc解决，读取一个快照数据； 已提交读之上，可以对select加共享锁，防止其他事务写； 避免幻读使用next-key锁（间隙锁+行锁），innodb自动加。 用法：(隔离级别：可重复读) 1234begin;select * from xxx where id between 10 and 15 lock in share mode;//for update...commit;//rollback; 防止间隙插入新数据； 防止已有数据，更新成间隙内的数据； 可串行化：是默认读加共享锁，写加排他锁，读写互斥。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://zfd.github.io/categories/数据库/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://zfd.github.io/tags/mysql/"},{"name":"acid","slug":"acid","permalink":"https://zfd.github.io/tags/acid/"}]},{"title":"linux","slug":"服务器/linux","date":"2018-04-18T22:34:46.000Z","updated":"2018-05-22T09:48:48.000Z","comments":true,"path":"2018/04/19/服务器/linux/","link":"","permalink":"https://zfd.github.io/2018/04/19/服务器/linux/","excerpt":"","text":"权限 权限是操作系统用来限制资源访问的机制，权限一般分为读、写、执行。 系统中每个文件都拥有特定的权限、所属用户及所属组，通过这样的机制来限制哪些用户、哪些组可以对特定的文件进行什么样的操作。 每个进程都是以某个用户的身份运行，所以进程的权限与该用户的权限一样，用户的权限越大，该进程所拥有的权限也就越大。 权限 对文件的影响 对目录的影响 r，读取 可读取文件内容 可列出目录内容 w，写入 可修改文件内容 可在目录创建、删除文件 x，执行 可作为命令执行 可访问目录内容 注：目录必须拥有’x’权限才可查看其内容。 UGO模型 U，代表user，所属用户权限； G，代表group，所属用户组权限； O，代表other，其他用户的权限； 权限设置 每个文件/目录权限基于UGO设置； 权限三个一组（rwx），对应UGO分别设置；（即共有3组，9个权限）； 例子： 123456789101112$ ls -ltotal 280drwxr-xr-x 1 zfd staff 18 Feb 18 17:34 README.mddrwxr-xr-x 1 zfd staff 1850 Feb 26 20:50 _config.ymldrwxr-xr-x 1 zfd staff 174 Apr 18 22:34 db.jsondrwxr-xr-x 321 zfd staff 10914 Feb 22 22:01 node_modulesdrwxr-xr-x 1 zfd staff 124449 Feb 22 22:01 package-lock.jsondrwxr-xr-x 1 zfd staff 743 Feb 18 18:06 package.jsondrwxr-xr-x 13 zfd staff 442 Mar 28 00:43 publicdrwxr-xr-x 5 zfd staff 170 Feb 18 17:34 scaffoldsdrwxr-xr-x 5 zfd staff 170 Feb 18 17:34 sourcedrwxr-xr-x 3 zfd staff 102 Feb 18 17:34 themes 说明： -rw-r–r– 1 zfd staff 18 Feb 18 17:34 README.md UGO模型的权限 链接数量 用户U 用户组G 大小 时间 文件/目录名 drwxr-xr-x： 第1位”d”是文件类型描述符，”d”是目录，”-“是文件； 2-4位”rwx”是U模型权限，这里表示可读、可写、可执行； 4-7位”r-x”是G模型权限，这里表示可读、不可写，可执行； 8-10位”r-x”是O模型权限，这里表示可读、不可写，可执行。 修改文件权限命令mode参数格式： u、g、o，分表代表用户、组、其他； a，代表ugo； +、-，代表加入或删除对应权限； r、w、x，代表三种权限； -R，代表递归地修改； 例子： 123456//chmod mode fileNamechmod u +rw test.md 给文件的所属用户添加rw权限chmod g -x test.md 给文件的所属组移除x权限chmod go +r test.md 给文件的所属组和其他用户添加r权限chmod a -x test.md 给文件的所属UGO三个模型均移除x权限 也支持3位8进制数值的方式修改： 1234567891011//八进制r = 4 (2 ^ 2)w = 2 (2 ^ 1)x = 1 (2 ^ 0)rw- = 4 + 2 + 0 = 6 二进制的110rwx = 4 + 2 + 1 = 7 二进制的111r-x = 4 + 0 + 1 = 5 二进制的101chmod 660 test.md 设置 UGO 权限为 rw-rw----chmod 777 test.md 设置 UGO 权限为 rwxrwxrwx","categories":[{"name":"服务器","slug":"服务器","permalink":"https://zfd.github.io/categories/服务器/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://zfd.github.io/tags/linux/"}]},{"title":"解决问题记录","slug":"笔记/解决问题记录","date":"2018-04-18T22:09:18.000Z","updated":"2018-05-22T09:48:48.000Z","comments":true,"path":"2018/04/19/笔记/解决问题记录/","link":"","permalink":"https://zfd.github.io/2018/04/19/笔记/解决问题记录/","excerpt":"","text":"网站或接口相应时间长，应该怎么排查？引用文件问题浏览器F12，看看哪个文件时间长，可以排查有可能是css、js引用了一些被墙住的地址，一直请求不到，所以时间很久。 解决：相关地方注释掉、引用本地的。 接口问题可以写个脚本内网访问一下接口，看看时间，时间长的就追踪到具体哪个业务慢。 解决：不是mysql问题，就业务逻辑优化；mysql问题可以找sql语句去explain一下，针对性优化；数据量大可以分表； 网络问题本地网络带宽；DNS解析时间等； 服务器问题查看linux服务器，cpu、io、network等状态； 解决：top、iostat、netstat、vmstat等命令；","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zfd.github.io/categories/笔记/"}],"tags":[{"name":"node","slug":"node","permalink":"https://zfd.github.io/tags/node/"}]},{"title":"redis集群","slug":"服务器/redis集群","date":"2018-04-17T13:33:16.000Z","updated":"2018-05-22T09:48:48.000Z","comments":true,"path":"2018/04/17/服务器/redis集群/","link":"","permalink":"https://zfd.github.io/2018/04/17/服务器/redis集群/","excerpt":"","text":"redis cluster：由多个服务于一个数据集合的redis实例组成的整体，redis实例分布在不同服务器。 集群特点 所有节点相互连接； 集群消息通过集群总线通信，集群总线端口为客户端端口+10000（固定值）； 节点与节点之间通过二进制协议进行通信； 客户端与节点之间通信和平常一样，通过文本协议进行； 集群节点不会代理查询； 数据按照slot存储分布在多个redis实例上； 集群节点挂掉会自动故障转移； 可以相对平滑扩容、缩容； 数据结构核心结构在cluster.h中定义： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 集群状态，每个节点都保存着一个这样的状态，记录了它们眼中的集群的样子。// 另外，虽然这个结构主要用于记录集群的属性，但是为了节约资源，// 有些与节点有关的属性，比如 slots_to_keys 、 failover_auth_count // 也被放到了这个结构里面。typedef struct clusterState &#123; ... // 指向当前节点的指针 clusterNode *myself; // 集群当前的状态：是在线还是下线 REDIS_CLUSTER_OK, REDIS_CLUSTER_FAIL, ... int state; // 集群节点名单（包括 myself 节点） // 字典的键为节点的名字，字典的值为 clusterNode 结构 dict *nodes; // 记录要从当前节点迁移到目标节点的槽，以及迁移的目标节点 // migrating_slots_to[i] = NULL 表示槽 i 未被迁移 // migrating_slots_to[i] = clusterNode_A 表示槽 i 要从本节点迁移至节点 A clusterNode *migrating_slots_to[REDIS_CLUSTER_SLOTS]; // 记录要从源节点迁移到本节点的槽，以及进行迁移的源节点 // importing_slots_from[i] = NULL 表示槽 i 未进行导入 // importing_slots_from[i] = clusterNode_A 表示正从节点 A 中导入槽 i clusterNode *importing_slots_from[REDIS_CLUSTER_SLOTS]; // 负责处理各个槽的节点 // 例如 slots[i] = clusterNode_A 表示槽 i 由节点 A 处理 clusterNode *slots[REDIS_CLUSTER_SLOTS]; // 跳跃表，表中以槽作为分值，键作为成员，对槽进行有序排序 // 当需要对某些槽进行区间（range）操作时，这个跳跃表可以提供方便 // 具体操作定义在 db.c 里面 zskiplist *slots_to_keys; ...&#125; clusterState;// 节点状态struct clusterNode &#123; ... // 节点标识 // 使用各种不同的标识值记录节点的角色（比如主节点或者从节点）， // 以及节点目前所处的状态（比如在线或者下线）。 int flags; // 由这个节点负责处理的槽 // 一共有 REDIS_CLUSTER_SLOTS / 8 个字节长 // 每个字节的每个位记录了一个槽的保存状态 // 位的值为 1 表示槽正由本节点处理，值为 0 则表示槽并非本节点处理 // 比如 slots[0] 的第一个位保存了槽 0 的保存情况 // slots[0] 的第二个位保存了槽 1 的保存情况，以此类推 unsigned char slots[REDIS_CLUSTER_SLOTS/8]; // 指针数组，指向各个从节点 struct clusterNode **slaves; // 如果这是一个从节点，那么指向主节点 struct clusterNode *slaveof; ...&#125;;// clusterLink 包含了与其他节点进行通讯所需的全部信息typedef struct clusterLink &#123; ... // TCP 套接字描述符 int fd; // 与这个连接相关联的节点，如果没有的话就为 NULL struct clusterNode *node; ...&#125; clusterLink; 集群通信通信端口集群中每个redis实例，都会使用两个tcp端口： 一个给客户端（redis-cli或应用程序等）使用； 另一个用于集群中实例相互通信的内部总线端口，此端口比第一个大10000。 通信协议 Redis集群采用P2P的Gossip（流言）协议，Gossip协议工作原理就是节点彼此不断通信交换信息，一段时间后所有的节点都会知道集群完整的信息，这种方式类似流言传播。 集群中每个节点通过一定规则挑选要通信的节点，每个节点可能知道全部节点，也可能仅知道部分节点，只要这些节点彼此可以正常通信，最终它们会达到一致的状态。 当节点出故障、新节点加入、主从角色变化、槽信息变更等事件发生时，通过不断的ping/pong消息通信，经过一段时间后所有的节点都会知道整个集群全部节点的最新状态，从而达到集群状态同步的目的。 组建集群（cluster meet） 组建集群，把各个独立的节点链接起来，构成一个包含多个节点的集群。 命令：cluster meet 客户端向节点A发送cluster meet 命令； 节点A为节点B创建一个clusterNode结构，并添加到clusterState.nodes字典里面，再向节点B发送meet消息； 节点B收到meet消息，会为节点A添加一个clusterNode结构，并添加到clusterState.nodes字典里面，再向节点A返回一条pong消息； 节点A收到pong消息，再向节点B发送ping消息； 节点B收到ping消息，握手完成； 之后，节点A会将节点B的信息通过Gossip协议传播给集群中的其他节点，让其他节点也跟节点B握手； 最终，节点B会被集群中所有节点认识。 消息处理（clusterProcessPacket） 更新接收消息计数器 查找发送者节点并且不是handshake节点 更新自己的epoch和slave的offset信息 处理MEET消息，使加入集群 从goosip中发现未知节点，发起handshake 对PING，MEET回复PONG 根据收到的心跳信息更新自己clusterState中的master-slave，slots信息 对FAILOVER_AUTH_REQUEST消息，检查并投票 处理FAIL，FAILOVER_AUTH_ACK，UPDATE信息 定时任务（clusterCron） 对handshake节点建立Link，发送Ping或Meet 向随机几点发送Ping 如果是从查看是否需要做Failover 统计并决定是否进行slave的迁移，来平衡不同master的slave数 判断所有pfail报告数是否过半数 心跳数据发送header信息： 所负责的slots的信息 主从信息 ip port信息 状态信息 发送其他节点gossip信息： ping_sent,pong_received ip、port信息 状态信息 分区原理槽（slot） 是一个虚拟的槽，总长度16384，为固定值，编号0~16383（用户可以配置）； 每个master节点负责一部分槽； 用户get/set时，先查找对应槽位，crc16(key)%16384，再查找对应节点，从而实现负载均衡。 注：crc，循环冗余校验（Cyclic Redundancy Check） 位序列结构 每个master节点维护一个16384/8=2048个unsigned int长度的位序列，用于检查某个槽是否拥有； 还维护一个槽到集群节点的映射，长度为16384的数组，数组下标为槽编号，数组的值为集群节点，用于快速查找槽所在的节点； 键哈希标签原理将一批数据放入同一个槽中，只需要按规则生成key，redis计算时只处理花括号内字符串： 123456789101112131415//如：设置2个key为，abc&#123;userId&#125;def，ghi&#123;userId&#125;jklunsigned int keyHashSlot(char *key, int keylen) &#123; int s, e; for (s = 0; s &lt; keylen; s++) if (key[s] == '&#123;') break; if (s == keylen) return crc16(key,keylen) &amp; 0x3FFF; for (e = s+1; e &lt; keylen; e++) if (key[e] == '&#125;') break; if (e == keylen || e == s+1) return crc16(key,keylen) &amp; 0x3FFF; return crc16(key+s+1,e-s-1) &amp; 0x3FFF;&#125; 请求重定向moved错误 请求的key对应的槽不在该节点上，节点将查看自身所保存的哈希槽到节点的映射记录，返回一个moved错误； 客户端需要再次向新节点重试。 ask错误 请求的key对应的槽目前属于migrating状态，并且当前节点找不到这个key了，节点返回ask错误。 ask会把对应槽的importing节点返回，让客户端重试； 客户端重试，先发送asking命令，节点将为客户端设置一个一次性的标志（flag），使得客户端可以执行一次针对importing状态的槽的命令请求，然后再发送真正的命令请求； 不必更新客户端所记录的槽至节点的映射。 数据迁移通信故障集群中每个节点都会定期向集群中的其他节点发送ping消息，以此交换各个节点状态信息，检查各个节点状态。 节点状态：在线、怀疑下线、已下线。 主节点状态fail集群里面，超过半数以上的主节点都将某主节点A报告为怀疑下线，那么A将被标记为已下线，并且标记他的节点处，会向集群广播他的fail消息。 多个从节点选主主节点，选举方式进行 故障转移 从下线主节点的所有从节点中选中一个从节点 被选中的从节点执行SLAVEOF NO NOE命令，成为新的主节点 新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己 新的主节点对集群进行广播PONG消息，告知其他节点已经成为新的主节点 新的主节点开始接收和处理槽相关的请求 集群状态fail 集群中任意master节点挂掉，并且该master没有slave，集群计入fail状态； 集群超过半数以上master挂掉，无论是否有slave，集群进入fail状态。","categories":[{"name":"服务器","slug":"服务器","permalink":"https://zfd.github.io/categories/服务器/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://zfd.github.io/tags/redis/"}]},{"title":"树","slug":"数据结构/树","date":"2018-04-13T09:54:56.000Z","updated":"2018-05-22T09:48:48.000Z","comments":true,"path":"2018/04/13/数据结构/树/","link":"","permalink":"https://zfd.github.io/2018/04/13/数据结构/树/","excerpt":"","text":"度：指一个节点拥有子节点的个数。深度：树的层数，根节点为第一层。叶子节点：度为0的节点，即没有子节点的节点。 树树的每一个节点，可以有N个子节点，但是每个子节点只有一个前驱节点。 二叉树除了子节点外，每个节点有两个分支，左右子树，每个节点最大度数为2； 满二叉树国内定义： 一个二叉树，每一层的节点数都达到最大值。（看上去就是一个三角形） 国外定义： 一个二叉树，非叶子节点度数都是2。（要么度为0，要么度为2） 平衡二叉树（二叉排序树）树的左右子树高度差不超过1，空树也是平衡二叉树；左子节点比父节点小，父节点比右子节点小。 常用实现方法：红黑树、AVL等。 红黑树也是平衡二叉树，C++的map、set都是红黑树实现的。 实现插入、删除，会用左旋、右旋维持树的平衡。 场景内存排序。 B树属于多叉树（平衡多路查找树），用在磁盘文件组织，如数据库索引。 相比平衡二叉树，每个节点包含的关键字增多了，层级减少了，从而减少数据查找次数和复杂度。 B+树B树的升级版，充分利用节点空间，让查询速度更稳定，接近于二叉法查找。 B+树与B树的区别： B+树的非叶子节点，不保存关键字记录的指针，每个节点所能保存的关键字个数大大增加； B+树的叶子节点，保存了父节点所有关键字和关键字记录的指针，每个叶子节点的关键字从小到大链接； B+树的根节点关键字数量和其叶子节点个数相等； B+的非叶子节点只进行数据索引，不会存实际的关键字记录的指针，所有数据地址必须要到叶子节点才能获取到，所以每次数据查询的次数都一样；","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://zfd.github.io/categories/数据结构/"}],"tags":[{"name":"tree","slug":"tree","permalink":"https://zfd.github.io/tags/tree/"}]},{"title":"写时复制","slug":"概念/写时复制","date":"2018-04-12T12:19:26.000Z","updated":"2018-05-22T09:48:48.000Z","comments":true,"path":"2018/04/12/概念/写时复制/","link":"","permalink":"https://zfd.github.io/2018/04/12/概念/写时复制/","excerpt":"","text":"概念 把A变量赋值给B变量时，不会立刻申请新的内存来存放B变量的值，而是通过一个计数器来公用内存；只有在其中一个引用指向变量的值发生变化时，才申请新空间保存值。总结：延迟分配资源。 好处只有在真正需要使用资源时才占用资源，减少资源的占用。 实现方式 ref_count，引用计数，标记此zval被多少个变量引用，为0时被销毁； is_ref，强制引用数，标记是否用&amp;的强制引用； 12345678910111213&lt;?php $foo = 1; xdebug_debug_zval('foo'); $bar = $foo; xdebug_debug_zval('foo'); $bar = 2; xdebug_debug_zval('foo'); ?&gt; //-----执行结果----- foo: (refcount=1, is_ref=0)=1 foo: (refcount=2, is_ref=0)=1 foo: (refcount=1, is_ref=0)=1 应用场景 php变量的多次赋值； php函数的参数传递； linux，fork进程；","categories":[{"name":"概念","slug":"概念","permalink":"https://zfd.github.io/categories/概念/"}],"tags":[{"name":"cow","slug":"cow","permalink":"https://zfd.github.io/tags/cow/"}]},{"title":"mysql相关锁","slug":"数据库/mysql相关锁","date":"2018-04-11T23:02:59.000Z","updated":"2018-05-22T09:48:48.000Z","comments":true,"path":"2018/04/12/数据库/mysql相关锁/","link":"","permalink":"https://zfd.github.io/2018/04/12/数据库/mysql相关锁/","excerpt":"","text":"乐观锁 乐观地认为数据没有别处修改，在完成业务的时候再拿锁（其实不会上锁，只是判断有无修改）。 mysql没有提供具体乐观锁，是要程序自己实现。 做法用version字段（主要用这个），或时间戳字段： select data as old_data， version as old_version from … where …； 处理data、version； update set date = new_data，version = new_version where version = old_version。 updated row &gt; 0，则成功提交事务；否则回滚。 悲观锁 悲观地认为数据会被别处修改，因此先确保获取锁成功再进行业务操作。（一锁二查三更新） 表锁、行锁、共享锁、排它锁，都是悲观锁，都是操作前先上锁。 mysql提供这种机制，直接用就行。 跟乐观锁开销比较 取锁成功情况下，乐观锁开销较小； 取锁失败情况下，需要回滚，则乐观锁开销较大。 总结：写操作少时，用乐观锁；写操作多时，用悲观锁。 表锁、行锁 表锁锁定整个表，开销小，加锁快；不会出现死锁；锁定力度大，锁冲突概率高，并发度低； 行锁锁定若干行，开销大，加锁慢；会出现死锁；锁定力度小，锁冲突概率低，并发度高。 共享锁、排他锁、自旋锁 共享锁：又叫读锁，加锁后，其他线程可读，不可写； 排它锁：又叫写锁，加锁后，其他线程不可读、不可写； 自旋锁：跟排它锁类似，但不会引起调用者睡眠。 排他锁、自旋锁，比较原理 排它锁：线程-&gt;sleep（加锁）-&gt;running（解锁），过程有上下文切换，cpu抢占，信号量发送等； 自旋锁：线程-&gt;running（加锁-&gt;解锁），死循环检测锁的标志位。 开销初始开销，排它锁较高；但时间越长，排它锁不变，自旋锁线性增长。 场景 互斥锁，适用于临界区锁时间较长的操作：临界区有IO操作，临界区竞争激烈，单核处理器等； 自旋锁，适用于临界区锁时间非常短，且CPU资源不紧张，一般用于多核的服务器。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://zfd.github.io/categories/数据库/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://zfd.github.io/tags/mysql/"},{"name":"lock","slug":"lock","permalink":"https://zfd.github.io/tags/lock/"}]},{"title":"堆内存、栈内存","slug":"概念/堆内存、栈内存","date":"2018-04-11T22:31:33.000Z","updated":"2018-05-22T09:48:48.000Z","comments":true,"path":"2018/04/12/概念/堆内存、栈内存/","link":"","permalink":"https://zfd.github.io/2018/04/12/概念/堆内存、栈内存/","excerpt":"","text":"进出顺序堆：顺序随意 栈：先进后出 内存分配堆：程序员手动分配，程序不释放，可能在程序结束后由系统回收，如：new，malloc； 栈：编译器自动分配、释放，速度快，存放函数的参数值，局部变量值等； 全局区（静态区）：全局变量、静态变量总是放一块的，初始化时放在同一块区域，未初始化时放在相邻的另一块区域，程序结束由系统释放； 常量区：放常量，程序结束由系统释放； 程序代码区：存放函数体的二进制代码，处理器会到这个区域取值并执行；","categories":[{"name":"概念","slug":"概念","permalink":"https://zfd.github.io/categories/概念/"}],"tags":[{"name":"heap","slug":"heap","permalink":"https://zfd.github.io/tags/heap/"},{"name":"stack","slug":"stack","permalink":"https://zfd.github.io/tags/stack/"}]},{"title":"分库、分区、分表、集群","slug":"数据库/分库、分区、分表、集群","date":"2018-04-10T21:58:45.000Z","updated":"2018-05-22T09:48:48.000Z","comments":true,"path":"2018/04/11/数据库/分库、分区、分表、集群/","link":"","permalink":"https://zfd.github.io/2018/04/11/数据库/分库、分区、分表、集群/","excerpt":"","text":"分库 分库：把一些不同业务的表放到不同数据库，不同数据库还可以放到不同的服务器。 作用减轻服务器的压力，增加数据库吞吐量。 分区 分区：mysql的一种技术设计，将一个表的数据分段在同一个服务器的多个物理位置存放。 表还是一个表，sql没有影响，业务层不用改。 作用减轻数据库的负担，提高数据库效率，提高表的增删改查效率。 适用场景表数据量大，访问量不大。 分区方式 range，范围 list，预定义列表 hash key，hash模式的一种延伸 composite，复合模式，以上模式组合使用 sql语句range： 12345678910create table range( id int(11), money int(11) unsigned not null, date datetime)partition by range(year(date))( partition p2007 values less than (2008), partition p2008 values less than (2009), partition p2009 values less than (2010), partition p2010 values less than maxvalue ); 分表 分表：开发人员的物理设计，将一个大表按照一定规则分解成多张子表。 表拆分成多个表，sql有影响，业务层需要调整。 作用减轻数据库的负担，提高数据库效率，提高表的增删改查效率。 适用场景表数据量大，访问量大。 集群 mysql集群是一个无共享的、分布式节点架构的存储方案，其目的是提供容错性和高性能。 通过多个mysql服务器分配负载，从而最大程序地达到高性能，通过在不同位置存储数据保证高可用性和冗余。 优缺点优点： 高可用性； 快速自动失效切换； 灵活分布式体系结构，没有单点故障； 高吞吐量、低延迟； 可拓展性强，支持在线扩容。 缺点： 不支持外键； 部署、管理、配置复杂； 占用磁盘空间大、内存大； 备份、恢复不方便； 重启时，数据节点将数据load到内存需要很长时间。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://zfd.github.io/categories/数据库/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://zfd.github.io/tags/mysql/"}]},{"title":"进程、进程控制块、进程上下文","slug":"概念/进程、进程控制块、进程上下文","date":"2018-04-09T22:23:07.000Z","updated":"2018-05-22T09:48:48.000Z","comments":true,"path":"2018/04/10/概念/进程、进程控制块、进程上下文/","link":"","permalink":"https://zfd.github.io/2018/04/10/概念/进程、进程控制块、进程上下文/","excerpt":"","text":"进程 进程：程序执行的一个实例； 线程：进程中执行的每个任务； 进程是资源分配的基本概念，是调度运行的基本单位； 进程至少有一个线程； 父子进程使用进程间通信机制，进程内线程通过读取、写入数据到进程变量来通信； 进程间通信进程控制块（PCB） PCB：描述和控制进程运行的一个数据结构，是进程存在的唯一标识。 组成 进程标识信息：内部标识符（供系统使用）、外部标识符（供用户进程访问）； 处理机状态：主要由处理机的各个寄存器内的信息组成； 进程调度信息：进程状态、进程优先级、事件、其他信息等； 进程控制信息：程序和数据地址，进程同步和通信机制，资源清单，链接指针； 进程上下文 进程上下文：程序的物理实体、支持程序执行的物理环境，合称为进程上下文。 进程是在操作系统支持下执行的，进程执行时需要操作系统为其设置相应的执行环境，如：系统堆栈、地址映像寄存器、程序计数器、打开文件表、相关通用寄存器等。 上文：已经执行的指令和数据，及在寄存器堆栈中的内容。 正文：正在执行的。 下文：待执行的。 进程上下文切换 挂起一个进程，将其上下文保存到存储区； 系统调度，选择一个新的进程，将其上下文恢复； 继续执行新的进程。 总结进程上下文的切换，也就是如何使寄存器与堆栈中的数据流入流出PCB的存储区。 进程上下文的切换，涉及系统调度和分配资源，这些都比较耗费CPU时间。","categories":[{"name":"概念","slug":"概念","permalink":"https://zfd.github.io/categories/概念/"}],"tags":[{"name":"process","slug":"process","permalink":"https://zfd.github.io/tags/process/"},{"name":"thread","slug":"thread","permalink":"https://zfd.github.io/tags/thread/"},{"name":"pcb","slug":"pcb","permalink":"https://zfd.github.io/tags/pcb/"}]},{"title":"select、poll、epoll","slug":"服务器/select、poll、epoll","date":"2018-03-30T14:39:42.000Z","updated":"2018-05-22T09:48:48.000Z","comments":true,"path":"2018/03/30/服务器/select、poll、epoll/","link":"","permalink":"https://zfd.github.io/2018/03/30/服务器/select、poll、epoll/","excerpt":"","text":"相关概念一个IO操作流程一个read（O）操作的2个阶段： 对于socket，等待从网络收到数据，并且在数据到达后，复制数据到内核缓冲区； 从内核缓冲区复制数据到用户进程缓冲区，以便进程处理。 同步、异步是一种通信机制，关注的是IO操作的结果返回方式。 同步：提交请求-&gt;等待服务器回应-&gt;处理完毕，中间一直等待； 异步：提交请求-&gt;处理其他事情，服务器回应-&gt;通知回调-&gt;处理完毕。 阻塞、非阻塞是一种调用机制，关注的是IO操作的执行状态。 阻塞：调用方等待IO操作完成后返回； 非阻塞：调用方不需要等待IO操作的完成就立即返回。 用户态、内核态 内核态：控制计算机硬件资源，并提供上层应用程序运行的环境；用户态：上层应用程序的活动空间，应用程序运行必须依赖内核提供的资源，如CPU资源、存储资源、I/O资源等。 文件描述符（file descriptor，简称fd） 在Linux下面一切皆文件，fd是内核为文件所创的索引，所有I/O操作都要调用fd来执行。 回调函数（callback） 回调函数就是一个通过函数指针调用的函数。 定义一个回调函数； 提供函数实现的一方在初始化的时候，将回调函数的函数指针注册给调用者； 当特定的事件或条件发生的时候，调用者使用函数指针调用回调函数对事件进行处理。 网络通信模型 阻塞式IO 非阻塞式IO IO多路复用 信号驱动IO 异步IO IO多路复用 I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。 select函数123456789101112131415161718192021222324252627282930313233343536#include &lt;sys/select.h&gt;#include &lt;sys/time.h&gt;/** * 参数： * maxfdp: 待监听的最大fd数+1。 * readSet：待监听的可读fd集合 * writeSet：待监听的可写fd集合 * exceptSet：待监听的异常fd集合 * timeval：指定超时，NULL为一直等到，0为不等待 * * 返回： * 就绪描述符的数目，超时返回0，出错返回-1， * 正常返回后，对应fd_set会设置相关满足条件的fd。 */int select(int maxfdp, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout);//fd_set相关操作void FD_ZERO(fd_set *fdset); //清空集合void FD_SET(int fd, fd_set *fdset);//将一个给定的文件描述符加入集合之中void FD_CLR(int fd, fd_set *fdset);//将一个给定的文件描述符从集合中删除int FD_ISSET(int fd, fd_set *fdset);//检查集合中指定的文件描述符是否可以读写//相关结构struct timeval &#123; long tv_sec;//seconds long tv_usec;//microseconds&#125;;#define __NFDBITS (8 * sizeof(unsigned long)) //32位编译器，unsigned long为4个字节#define __FD_SETSIZE 1024#define __FDSET_LONGS (__FD_SETSIZE/__NFDBITS)typedef struct &#123; unsigned long fds_bits [__FDSET_LONGS];&#125; __kernel_fd_set; 缺点 单个进程监听的fd数量有限，最多为1024；（能改，但是改后影响效率）； 每次调用select，都需要遍历所有fd，才能发现哪些发生了事件，效率慢； 内存复制开销大，需要从用户空间、内核空间来回拷贝fd_set； pollpoll的实现和select非常相似，只是描述fd集合的方式不同，poll使用pollfd结构而不是select的fd_set结构，其他的都差不多。 就少了select的fd数量限制，其他缺点仍存在。 函数123456789# include &lt;poll.h&gt;int poll(struct pollfd * fds, unsigned int nfds, int timeout);//结构truct pollfd &#123; int fd;//文件描述符 short events;//等待的事件 short revents;//实际发生了的事件&#125;; epoll函数12345678//创建epoll句柄，返回值为句柄，即epfdint epoll_create(int size)；//注册要监听的事件类型int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；//等待事件的发生int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)； 解决select、poll的缺点 epoll_create，提前准备好相关资源（开辟内核缓冲区，创建红黑树和就绪链表），注册事件只是往里面添加新的fd，所支持的fd上限是最大可以打开文件的数目； epoll_ctl，注册事件时，就会把fd拷贝进内核，保证每个fd只拷贝一次； epoll_ctl，注册事件时，为每个fd指定一个回调函数，当设备就绪，唤醒队列上的等待者时，就会调用回调函数，把就绪的fd加入一个就绪链表； epoll_wait，等待事件的发生，只需要查看就绪链表中有没有就绪的fd，并且返回的fd是通过mmap让内核和用户空间共享同一块内存实现传递的，减少了不必要的拷贝； 工作模式 LT模式（level trigger，默认模式）：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件； ET模式（edge trigger）：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。 ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。 总结epoll比select和poll高效的原因主要有： 减少了用户态和内核态之间的fd拷贝； 减少了对就绪fd的遍历；","categories":[{"name":"服务器","slug":"服务器","permalink":"https://zfd.github.io/categories/服务器/"}],"tags":[{"name":"epoll","slug":"epoll","permalink":"https://zfd.github.io/tags/epoll/"},{"name":"select","slug":"select","permalink":"https://zfd.github.io/tags/select/"},{"name":"poll","slug":"poll","permalink":"https://zfd.github.io/tags/poll/"}]},{"title":"简单查找算法","slug":"算法/简单查找算法","date":"2018-03-22T17:45:14.000Z","updated":"2018-05-22T09:48:48.000Z","comments":true,"path":"2018/03/23/算法/简单查找算法/","link":"","permalink":"https://zfd.github.io/2018/03/23/算法/简单查找算法/","excerpt":"","text":"算法总结 时间复杂度：一个算法执行所耗费的时间。空间复杂度：运行完一个程序所需内存的大小。 排序算法 平均时间复杂度 平均空间复杂度 二分查找 O(log2n) 递归：O(log2n)，非递归：O(1) 二分查找（Binary Search）算法描述 首先元素队列要有序； 然后跟队列中间位置的比较，根据大小选择左或右队列，再次折半查找； 直到找到相同元素或无匹配。 代码实现注：默认从小到大排序。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?php//递归function BinarySearch($arr, $intV, $intL, $intR) &#123; if ($intL &gt; $intR) &#123; return -1; &#125; $intM = intval(($intL + $intR) / 2); if ($intV == $arr[$intM]) &#123; return $intM; &#125; else if ($intV &lt; $arr[$intM]) &#123; return BinarySearch($arr, $intV, $intL, $intM - 1); &#125; else &#123; return BinarySearch($arr, $intV, $intM + 1, $intR); &#125;&#125;//非递归function BinarySearch2($arr, $intV, $intL, $intR) &#123; while($intL &lt;= $intR) &#123; $intM = intval(($intL + $intR) / 2); if ($intV == $arr[$intM]) &#123; return $intM; &#125; else if ($intV &lt; $arr[$intM]) &#123; $intR = $intM - 1; &#125; else &#123; $intL = $intM + 1; &#125; &#125; return -1;&#125;$arr = array(0,1,2,3,4,5,6,7,8);$intI = BinarySearch($arr, 2, 0, 8);//$intI = BinarySearch2($arr, 2, 0, 8);var_export($intI);","categories":[{"name":"算法","slug":"算法","permalink":"https://zfd.github.io/categories/算法/"}],"tags":[{"name":"php","slug":"php","permalink":"https://zfd.github.io/tags/php/"},{"name":"search","slug":"search","permalink":"https://zfd.github.io/tags/search/"}]},{"title":"简单排序算法","slug":"算法/简单排序算法","date":"2018-03-22T17:45:08.000Z","updated":"2018-05-22T09:48:48.000Z","comments":true,"path":"2018/03/23/算法/简单排序算法/","link":"","permalink":"https://zfd.github.io/2018/03/23/算法/简单排序算法/","excerpt":"","text":"算法总结 时间复杂度：一个算法执行所耗费的时间。空间复杂度：运行完一个程序所需内存的大小。 排序算法 平均时间复杂度 平均空间复杂度 冒泡排序 O(n2) O(1) 选择排序 O(n2) O(1) 插入排序 O(n2) O(1) 希尔排序 O(nlog2n) O(1) 归并排序 O(nlog2n) O(n) 快速排序 O(nlog2n) O(log2n) 堆排序 O(nlog2n) O(1) 桶排序 O(n+k) O(n+k) 下面排序，1～n个元素，默认从小到大排列。 冒泡排序（Bubble Sort）算法描述 比较第1个、第2个元素，如果第1个比较大，则交换2个元素的位置； 比较第2个、第3个元素，3、4，4、5，以此类推，最后得到第n个元素为最大值； 对1～n－1的剩余元素，重复1、2步骤的操作，以此类推，每一次循环后，最大的元素在右边，直到排序完成。 代码实现1234567891011121314151617181920212223&lt;?phpfunction swap(&amp;$arr, $intI, $intJ) &#123; $intTmp = $arr[$intI]; $arr[$intI] = $arr[$intJ]; $arr[$intJ] = $intTmp;&#125;function bubbleSort($arr) &#123; $intN = count($arr); for ($intI = 0; $intI &lt; $intN; $intI++) &#123; for ($intJ = 0; $intJ &lt; $intN - $intI - 1; $intJ++) &#123; if ($arr[$intJ] &gt; $arr[$intJ + 1]) &#123; swap($arr, $intJ, $intJ + 1); &#125; &#125; &#125; return $arr;&#125;$arr = array(2, 5, 6, 3, 1, 4, 3);$arr = bubbleSort($arr);var_export($arr); 选择排序（Selection Sort）算法描述 从1～n里面，取第1个元素依次去跟其它元素比较； 如果遇到比他大的，则记录较大的元素下标i，用元素i继续去比较； 最后把i跟n交换位置，第n个元素为最大值； 从1～n－1里面，重复步骤1～3的操作，直到排序完成。 代码实现12345678910111213141516171819202122232425&lt;?phpfunction swap(&amp;$arr, $intI, $intJ) &#123; $intTmp = $arr[$intI]; $arr[$intI] = $arr[$intJ]; $arr[$intJ] = $intTmp;&#125;function selectionSort($arr) &#123; $intN = count($arr); for ($intI = 0; $intI &lt; $intN; $intI++) &#123; $intM = 0; for ($intJ = 0; $intJ &lt; $intN - $intI - 1; $intJ++) &#123; if ($arr[$intM] &lt; $arr[$intJ + 1]) &#123; $intM = $intJ + 1; &#125; &#125; swap($arr, $intM, $intJ); &#125; return $arr;&#125;$arr = array(2, 5, 6, 3, 1, 4, 3);$arr = selectionSort($arr);var_export($arr); 插入排序（Insertion Sort）算法描述 取第1个元素，默认为已排序； 从右边未排序的元素中，取第一个元素，跟已排序的元素做比较（从后往前）； 如果遇到比他大的，则交换位置，遇到比他小的或到头了，则停止； 重复1～3操作，直到排序完成。 代码实现12345678910111213141516171819202122232425&lt;?phpfunction swap(&amp;$arr, $intI, $intJ) &#123; $intTmp = $arr[$intI]; $arr[$intI] = $arr[$intJ]; $arr[$intJ] = $intTmp;&#125;function insertionSort($arr) &#123; $intN = count($arr); for ($intJ = 1; $intJ &lt; $intN; $intJ++) &#123; $intI = $intJ - 1; $intT = $intJ; while ($intI &gt;= 0 &amp;&amp; $arr[$intT] &lt; $arr[$intI]) &#123; swap($arr, $intI, $intT); $intI--; $intT--; &#125; &#125; return $arr;&#125;$arr = array(2, 5, 6, 3, 1, 4, 3);$arr = insertionSort($arr);var_export($arr); 快速排序（Quick Sort）算法描述 取基准：取第1个元素作为基准； 划分区：用基准元素跟其它比较，比他小的放在他左边，比他大的放在他右边； 递归：把左、右两边的元素分别递归重复步骤1、2，最后把结果合并。 代码实现方法1： 1234567891011121314151617181920212223242526&lt;?phpfunction quickSort($arr) &#123; if (!isset($arr[1])) &#123; return $arr; &#125; $intPivot = $arr[0]; $arrL = array(); $arrR = array(); for ($intI = 1; $intI &lt; count($arr); $intI++) &#123; if ($arr[$intI] &lt; $intPivot) &#123; $arrL[] = $arr[$intI]; &#125; else &#123; $arrR[] = $arr[$intI]; &#125; &#125; $arrL = quickSort($arrL); $arrL[] = $intPivot; $arrR = quickSort($arrR); return array_merge($arrL, $arrR);&#125;$arr = array(2, 5, 6, 3, 1, 4, 3);$arr = quickSort($arr);var_export($arr); 方法2： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpfunction _quickSort(&amp;$arr, $intL, $intR) &#123; if ($intL &gt;= $intR) &#123; return; &#125; $intI = $intL; $intJ = $intR; $intPivot = $arr[$intI]; while ($intI &lt; $intJ) &#123; while ($intI &lt; $intJ &amp;&amp; $intPivot &lt;= $arr[$intJ]) &#123; $intJ--; &#125; $arr[$intI] = $arr[$intJ]; while ($intI &lt; $intJ &amp;&amp; $intPivot &gt; $arr[$intI]) &#123; $intI++; &#125; $arr[$intJ] = $arr[$intI]; &#125; $arr[$intI] = $intPivot; _quickSort($arr, $intL, $intI - 1); _quickSort($arr, $intI + 1, $intR);&#125;function quickSort($arr) &#123; if (!isset($arr[1])) &#123; return $arr; &#125; _quickSort($arr, 0, count($arr) - 1); return $arr;&#125;$arr = array(2, 5, 6, 3, 1, 4, 3);$arr = quickSort($arr);var_export($arr); 堆排序（Heap Sort）算法描述 将待排序元素，构成大顶堆（二叉树结构，顶部为最大值），此堆为初始无序区； 将堆顶第一个元素与最后一个n元素交换，得到新的无序区和有序区。 重复步骤1~2，直到无序区没有元素。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpfunction swap(&amp;$arr, $intI, $intJ) &#123; $intTmp = $arr[$intI]; $arr[$intI] = $arr[$intJ]; $arr[$intJ] = $intTmp;&#125;function heapify(&amp;$arr, $intI, $intJ) &#123; $intL = $intI * 2 + 1; $intR = $intL + 1; $intMax = $intI; if ($intL &lt;= $intJ &amp;&amp; $arr[$intL] &gt; $arr[$intMax]) &#123; $intMax = $intL; &#125; if ($intR &lt;= $intJ &amp;&amp; $arr[$intR] &gt; $arr[$intMax]) &#123; $intMax = $intR; &#125; if ($intI != $intMax) &#123; swap($arr, $intI, $intMax); heapify($arr, $intMax, $intJ); &#125;&#125;function heapSort($arr) &#123; $intJ = count($arr) - 1; if ($intJ &lt;= 0) &#123; return $arr; &#125; for ($intI = $intJ / 2 - 1; $intI &gt;= 0; $intI--) &#123; heapify($arr, $intI, $intJ); &#125; for ($intI = $intJ; $intI &gt;= 1; $intI--) &#123; swap($arr, 0, $intI); heapify($arr, 0, $intI - 1); &#125; return $arr;&#125;$arr = array(2, 5, 6, 3, 1, 4, 3);$arr = heapSort($arr);var_export($arr); 桶排序（Bucket Sort）算法描述 假设待排序的一组元素分布在一个范围内，并将这一范围划分为N个子范围，也就是桶； 将待排序的一组元素，分档放入这些桶，并将桶中的元素进行排序； 将每个桶中的数据有序地合并起来。 代码实现123456789101112131415161718192021&lt;?phpfunction bucketSort($arr, $intMax) &#123; $arrBucket = array_fill(0, $intMax + 1, 0); for ($intI = 0; $intI &lt; count($arr); $intI++) &#123; $arrBucket[$arr[$intI]]++; &#125; $arrSort = array(); for ($intI = 0; $intI &lt;= $intMax; $intI++) &#123; for ($intJ = 1; $intJ &lt;= $arrBucket[$intI]; $intJ++) &#123; $arrSort[] = $intI; &#125; &#125; return $arrSort;&#125;$arr = array(2, 5, 6, 3, 1, 4, 3);$arr = bucketSort($arr, 6);var_export($arr);","categories":[{"name":"算法","slug":"算法","permalink":"https://zfd.github.io/categories/算法/"}],"tags":[{"name":"php","slug":"php","permalink":"https://zfd.github.io/tags/php/"},{"name":"sort","slug":"sort","permalink":"https://zfd.github.io/tags/sort/"}]},{"title":"memcached、redis比较","slug":"服务器/memcached、redis比较","date":"2018-03-19T17:03:13.000Z","updated":"2018-05-22T09:48:48.000Z","comments":true,"path":"2018/03/20/服务器/memcached、redis比较/","link":"","permalink":"https://zfd.github.io/2018/03/20/服务器/memcached、redis比较/","excerpt":"","text":"memcached优点 存储数据量大于10w时，性能更高； 存储结构简单（key/value），对内存利用率更高； redis优点 存储小数据，性能更高； 支持结构类型更丰富； 支持持久化，存储数据更安全； 支持数据备份，主从模式； 总结有持久化需求或者对数据结构和处理有更高要求，选择redis；其他简单的key/value存储，选择memcache。","categories":[{"name":"服务器","slug":"服务器","permalink":"https://zfd.github.io/categories/服务器/"}],"tags":[{"name":"nosql","slug":"nosql","permalink":"https://zfd.github.io/tags/nosql/"},{"name":"memcached","slug":"memcached","permalink":"https://zfd.github.io/tags/memcached/"},{"name":"redis","slug":"redis","permalink":"https://zfd.github.io/tags/redis/"}]},{"title":"shell命令","slug":"linux/shell命令","date":"2018-03-01T14:15:20.000Z","updated":"2018-05-22T09:48:48.000Z","comments":true,"path":"2018/03/01/linux/shell命令/","link":"","permalink":"https://zfd.github.io/2018/03/01/linux/shell命令/","excerpt":"","text":"123456789101112131415#!bin/sh#md5当前目录所有xxx.sql=&gt;xxx.sql.md5for file in *do if test -f $file then fName=$&#123;file%.*&#125; fSuffix=$&#123;file##*.&#125; if [ \"$fSuffix\" = \"sql\" ] then md5sum $file | cut -d ' ' -f 1 &gt; \"$file\".md5 fi fi done","categories":[{"name":"linux","slug":"linux","permalink":"https://zfd.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://zfd.github.io/tags/linux/"},{"name":"shell","slug":"shell","permalink":"https://zfd.github.io/tags/shell/"}]},{"title":"grep命令","slug":"linux/grep命令","date":"2018-03-01T14:10:38.000Z","updated":"2018-05-22T09:48:48.000Z","comments":true,"path":"2018/03/01/linux/grep命令/","link":"","permalink":"https://zfd.github.io/2018/03/01/linux/grep命令/","excerpt":"","text":"主要用来查文件内容。 12345678910111213141516171819202122232425-a 不要忽略二进制数据。-A&lt;显示列数&gt; 除了显示符合范本样式的那一行之外，并显示该行之后的内容。-b 在显示符合范本样式的那一行之外，并显示该行之前的内容。-c 计算符合范本样式的列数。-C&lt;显示列数&gt;或-&lt;显示列数&gt; 除了显示符合范本样式的那一列之外，并显示该列之前后的内容。-d&lt;进行动作&gt; 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作。-e&lt;范本样式&gt; 指定字符串作为查找文件内容的范本样式。-E 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。-f&lt;范本文件&gt; 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式。-F 将范本样式视为固定字符串的列表。-G 将范本样式视为普通的表示法来使用。-h 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。-H 在显示符合范本样式的那一列之前，标示该列的文件名称。-i 忽略字符大小写的差别。-l 列出文件内容符合指定的范本样式的文件名称。-L 列出文件内容不符合指定的范本样式的文件名称。-n 在显示符合范本样式的那一列之前，标示出该列的编号。-q 不显示任何信息。-R/-r 此参数的效果和指定“-d recurse”参数相同。-s 不显示错误信息。-v 反转查找。-w 只显示全字符合的列。-x 只显示全列符合的列。-y 此参数效果跟“-i”相同。-o 只输出文件中匹配到的部分。","categories":[{"name":"linux","slug":"linux","permalink":"https://zfd.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://zfd.github.io/tags/linux/"},{"name":"grep","slug":"grep","permalink":"https://zfd.github.io/tags/grep/"}]},{"title":"PHP核心技术与最佳实践","slug":"笔记/PHP核心技术与最佳实践","date":"2018-03-01T10:02:32.000Z","updated":"2018-05-22T09:48:48.000Z","comments":true,"path":"2018/03/01/笔记/PHP核心技术与最佳实践/","link":"","permalink":"https://zfd.github.io/2018/03/01/笔记/PHP核心技术与最佳实践/","excerpt":"","text":"面向对象的的核心概念面向对象 面向对象（OO）：是软件开发方法。 面向对象编程（OOP）：将对象作为程序的基本单元，把程序和数据封装其中，以提高软件的重用性、灵活性和可拓展性。 序列化、反序列化 对象的底层实现：“属性数组”+“方法数组”。 对象的序列化：把保存在内存中的对象的属性保存起来，并且可以在需要的时候还原出来。（serialize） 继承、封装、多态 面向对象思想的三大要素：继承、封装、多态。 作用：让代码更具开放性、可扩充性，增加代码的重用性、提高软件的可维护性。 继承作用：继承一个公共类，可以使用一些公有方法，提升程序的效率，减少代码的重复。 用关键字extends实现继承。 子类只能继承父类的非私有属性。 子类继承父类后，相当于将父类的属性和方法copy到子类，可以直接使用$this调用该属性。 PHP只能单继承，不支持一个类继承多个类。但是一个类可以进行多层继承（即A继承于B，而C又继承于A，C通过A间接继承了B）。 封装作用：防止代码冗余，也可以方便代码的调用。 多态概念：同一个类的不同子类表现出不同的形态。（子类重写父类的方法） 反射 通过反射，可以找到一个对象所属的类及拥有的方法。在平常开发中，用到反射的地方不多：一个是对对象进行调试，另一个是获取类的信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpclass person &#123; public $name; public $gender; public function say() &#123; echo $this-&gt;name, \" \", $this-&gt;gender, \"\\r\\n\"; &#125; public function set($name, $value) &#123; echo \"Setting $name to $value \\r\\n\"; $this-&gt;$name = $value; &#125; public function get($name) &#123; if (!isset($this-&gt;$name)) &#123; echo '未设置'; $this-&gt;$name = \"正在为你设置默认值\"; &#125; return $this-&gt;$name; &#125;&#125;$student = new person();$student-&gt;name = 'Tom';$student-&gt;gender = 'male';$student-&gt;age = 24;// 获取对象属性列表$reflect = new ReflectionObject($student);$props = $reflect-&gt;getProperties();foreach ($props as $prop) &#123; print $prop-&gt;getName() . \"\\n\";&#125;// 获取对象方法列表$m = $reflect-&gt;getMethods();foreach ($m as $prop) &#123; print $prop-&gt;getName() . \"\\n\";&#125;// 返回对象属性的关联数组var_dump(get_object_vars($student));// 类属性var_dump(get_class_vars(get_class($student)));// 返回由类的方法名组成的数组var_dump(get_class_methods(get_class($student)));// 获取对象属性列表所属的类echo get_class($student); 异常 Deprecated最低级别错误，程序继续执行 Notice 通知级别的错误 如直接使用未声明变量，程序继续执行 Warning 警告级别的错误，可能得不到想要的结果 Fatal error 致命级别错误致命级别错误，程序不往下执行 parse error 语法解析错误，最高级别错误，连其他错误信息也不呈现出来 E_USER_相关错误 用户设置的相关错误 error_reporting(-1)显示所有错误，error_reporting(0)屏蔽所有错误。 error_reporting(E_ALL&amp;~E_NOTICE)不显示通知级别的错误。“~”表示非。 PHP网络技术及应用Web 基础HTTP（HyperText Transfer Protocol，超文本传输协议）。WWW（World Wide Web）的三种技术：HTML、HTTP、URL。RFC（Request for Comments，征求修正意见书），互联网的设计文档。 URI（Uniform Resource Indentifier，统一资源标识符）URL（Uniform Resource Locator，统一资源定位符）URN（Uniform Resource Name，统一资源名称），例如 urn:isbn:0-486-27557-4URI 包含 URL 和 URN，目前 WEB 只有 URL 比较流行，所以见到的基本都是 URL。 HTTP请求 CRLF：Carriage-Return Line-Feed，即回车+换行，\\r\\n 请求行：请求方法 + URL + 协议/版本 + CRLF，之间由空格分隔 请求头：key + “:” + value + CRLF （N行） 空行 请求正文：Get请求没有正文/Post请求正文是参数 HTTP响应 状态行：协议/版本 + 状态码 + 状态码描述 + CRLF，之间由空格分隔 响应头：key + “:” + value + CRLF （N行） 空行 响应正文：html/json等 响应消息：1xx:信息响应类，表示接收到请求并且继续处理2xx:处理成功响应类，表示动作被成功接收、理解和接受3xx:重定向响应类，为了完成指定的动作，必须接受进一步处理4xx:客户端错误，客户请求包含语法错误或者是不能正确执行5xx:服务端错误，服务器不能正确执行一个正确的请求 PHP模板引擎的原理和实践smarty（直接看smarty就可以了） smarty是基于PHP开发的PHP模板引擎，他提供了php逻辑与html页面的分离 工作流程： 把需要显示的变量，赋值，塞到对象的内部属性中的一个数组里 然后编译模板，将标签解析成相应的php echo代码 引入编译后的php文件 使用步骤： Smarty是一个类，要使用的话，必须引入在进行实例化 使用assign给模板赋值 使用display方法（从编译到输出） 优点： 速度快：相对于其他模板引擎 编译型：把模板文件替换成一个HTML+PHP混合的PHP文件，当下模板没有改变，将自动转向编译文件 缓存技术：一定缓存时间内，用户最终看到的html文件缓存成一个静态的html页 插件技术：可以自定义插件 缺点： 编译模板，浪费时间 要把变量再重新赋值到对象的属性中，增大了开销 不适用用实时更新，股票、天气等 不适用于小项目，小项目直接开发更快 Smarty.class.php： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?php class Smarty //此类就是libs中的Smarty.class.php类&#123; public $leftlimit=\"&lt;&#123;\"; //左分隔符 public $rightlimit=\"&#125;&gt;\";//右分隔符 public $attr; //存放变量信息的数组 //注册变量 function assign($k,$v) &#123; $this-&gt;attr[$k] = $v; //向数组中添加一个值,相当于$sttr[0]=\"sdc123\" &#125; //显示模板 function display($name) &#123; //1.造模板路径 $filename = $mubanlujing.$name; //2.获取模板内容,内容是一大串代码,(例如模板为index.html) $str=file_get_contents($filename); /*$str里面的代吗内容 &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&#123;$aa&#125;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; */ //3.用正则去匹配字符串中出现的&#123;&#125;里面的内容 //4.将内容读取（读取到的是数组里面的key），拿key去数组attr里面取value值 /*$str里面的代码内容 &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;?php echo $attr[key]?&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; */ //5.将str里面的内容保存在缓存文件里面 file_put_contents($filename,$str);//$filename是新的文件 //6.将存储的文件加载到当前页面 include(filename); &#125; &#125; 缓存详解 缓存：凡是位于速度相差较大的两种介质之间，用于协调两者数据传输速度差异的结构。 作用 性能：解决高并发，大数据场景下，热点数据访问的性能问题。提供高性能的数据快速访问。(主要作用) 稳定性：一些重复请求每次都要处理，会加大服务器的资源消耗，影响系统稳定性。 可用性：提供数据的服务挂了，缓存可以在一段时间内正常提供用户支持，提高系统可用性。 原理减少计算量，缩短请求流程（网络i/o、硬盘i/o）： 将数据写入/读取速度更快的存储（设备）； 将数据缓存到离应用最近的位置； 将数据缓存到离用户最近的位置。 应用理论上，web的每一层都可以被缓存。 CPU缓存； 内存：Memcached这样的Key Value内存缓存； 数据库：Query cache，Table cache，Thread cache； 应用程序代码级别：Smarty文件缓存； 浏览器：浏览器缓存； 注：理论上各层都可以被缓存。 缓存的存放位置：CPU、内存、硬盘。 缓存的三个要素 命中率，更新策略，最大数据量。 命中率命中率 = 请求缓存次数 / 缓存返回正确结果，比例越高越好，比例过低可能会造成反效果。 更新策略超出缓存最大数据量时，清理缓存的常用策略： FIFO（first in first out），先进先出；（如：mysql的query cache） LFU（less frequently used），最少使用； LRU（least recently used），最近最少使用； 最大数据量缓存元素的最大个数 或 所能使用的最大存储空间。 超出最大数据量时，一般如下处理： 停止缓存服务，所有缓存数据清空； 拒绝写入，拒绝更新； 根据缓存策略，清理旧数据（还可以备份旧数据）； Memcached使用与实践 本质上是一个key/value的内存数据库，但是不支持数据的持久化，服务器关闭之后数据全部丢失。 为什么要用memcached？ 对数据库的高并发读写；（关系型数据库承受不了高并发的读写，如：每秒上万次） 对海量数据的处理；（数据量上亿左右，表的读写效率低） redis使用与实践 本质上是一个key/value的内存数据库。 数据结构 结构类型 结构存储的值 结构的读写能力 string 字符串、整形、浮点数 对字符串整个或部分操作，对整形、浮点数自增或自减 list 链表，每个节点都包含一个字符串 两端push、pop；根据偏移量修剪；读取单个或多个元素；根据值查找或移除元素 set 无序集合，包含string，并且每个字符串都是唯一 CRUD元素；与集合计算交集、并集、差集；从集合随机获取元素 hash 散列表，包含键值对，key/value 都是字符串类型 CRUD键值对；获取所有键值对 zset 有序集合，字符串成语与浮点数分值之间的有序映射，元素排序顺序由分值大小决定 CRUD元素；根据分值范围或成员获取元素 简单动态字符串（SDS）1234567891011/* * 保存字符串对象的结构 */ struct sdshdr &#123; // buf 中已占用空间的长度 int len; // buf 中剩余可用空间的长度 int free; // 数据空间 char buf[]; &#125;; 优点： 常数复杂度获取字符串的长度：len属性保存了字符串的长度；（’\\0’空字符不计入len） 杜绝缓冲区溢出：当对SDS进行修改时，先检查SDS的空间是否满足修改所需要的空间要求，如果不满足，则先扩展空间，然后执行修改操作； 减少修改字符串带来的内存重分配次数： 空间预分配：当SDS的长度小于1MB时，分配（2 * len + 1B）的空间；当SDS的长度大于等于1MB时，分配（len + 1MB + 1B）的空间； 惰性空间释放：当缩短字符串时，并不会立即使用内存重分配来回收多出来的字符，而是记录在free属性中； 链表1234567891011121314151617181920212223242526272829/* * 双端链表节点 */ typedef struct listNode &#123; // 前置节点 struct listNode *prev; // 后置节点 struct listNode *next; // 节点的值 void *value; &#125; listNode; /* * 双端链表结构 */ typedef struct list &#123; // 表头节点 listNode *head; // 表尾节点 listNode *tail; // 节点值复制函数 void *(*dup)(void *ptr); // 节点值释放函数 void (*free)(void *ptr); // 节点值对比函数 int (*match)(void *ptr, void *key); // 链表所包含的节点数量 unsigned long len; &#125; list; 字典123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* * 字典 */ typedef struct dict &#123; // 类型特定函数，Redis为不同用途的字典设置不同的类型特定函数 dictType *type; // 私有数据，传递给特定类型函数的可选参数 void *privdata; // 哈希表，一般情况下字典使用ht[0]，ht[1]只会在对ht[0]进行rehash时使用 dictht ht[2]; // rehash 索引 // 当 rehash 不在进行时，值为 -1 int rehashidx; /* rehashing not in progress if rehashidx == -1 */ // 目前正在运行的安全迭代器的数量 int iterators; /* number of iterators currently running */ &#125; dict; /* * 哈希表 * 每个字典都使用两个哈希表，从而实现渐进式 rehash 。 */ typedef struct dictht &#123; // 哈希表数组，存放具体的键值对 dictEntry **table; // 哈希表大小 unsigned long size; // 哈希表大小掩码，用于计算索引值 // 总是等于 size - 1 unsigned long sizemask; // 该哈希表已有节点的数量 unsigned long used; &#125; dictht; /* * 哈希表节点 */ typedef struct dictEntry &#123; // 键 void *key; // 值 union &#123; void *val; uint64_t u64; int64_t s64; &#125; v; // 指向下个哈希表节点，形成链表 struct dictEntry *next; &#125; dictEntry; 跳跃表（skiplist）123456789101112131415161718192021222324252627282930/* * 跳跃表 */ typedef struct zskiplist &#123; // 表头节点和表尾节点 struct zskiplistNode *header, *tail; // 表中节点的数量 unsigned long length; // 表中层数最大的节点的层数，表头结点的层数不计算在内 int level; &#125; zskiplist; /* * 跳跃表节点 */ typedef struct zskiplistNode &#123; // 成员对象 robj *obj; // 分值，跳跃表中节点按各自所保存的分值从小到大排列 double score; // 后退指针，指向当前节点的前一个节点 struct zskiplistNode *backward; // 层，每次创建一个新节点，程序按幂次定律随机生成一个1~32的值作为level数组的大小（层高度） struct zskiplistLevel &#123; // 前进指针 struct zskiplistNode *forward; // 跨度，前进指针所指向的节点和当前节点的距离 unsigned int span; &#125; level[]; &#125; zskiplistNode; 整数集合（intset）12345678typedef struct intset &#123; // 编码方式 uint32_t encoding; // 集合包含的元素数量 uint32_t length; // 保存元素的数组，各项在数组中按值大小有序地排序并且不包含重得项 int8_t contents[]; &#125; intset; 压缩列表（ziplist）redis优势 Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。 Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 持久化 内存快照（snapshotting） 每个一段时间进行一次内存快照，把内存中的数据写入二进制文件中（*.rdb）；save，在主进程操作，阻塞主进程，不能快速响应请求；bgsave，fork一个子进程操作，主进程继续处理请求，完成后通知主进程； 缺点：每次都是全部内存数据写入，数据量大会操作频繁，影响性能。 日志追加（append only file） 把增加、修改数据的命令通过write函数追加到文件尾部（*.aof）；redis重启时读取所有命令并且执行，从而把数据写入内存； 缺点：日志文件膨胀比较快，如nums自增100次，恢复只需要一次set nums 100，其他命令多余。 优化：bgrewriteaof命令，类似于内存快照方式，把命令保存到临时文件，最后再替换原来的日志文件。 主从复制 master服务器 slave服务器 1.连接（或重新连接）主服务器，发送同步（SYNC）命令 2.开始执行bgsave，生成快照文件（.rdb），然后向slave服务器发送，并使用缓冲区记录后续执行的写命令 3.丢弃所有旧数据，接收并载入master服务器发来的快照文件，解释并处理完毕后，正常接收命令 4.继续发送缓冲区记录的后续写命令；发送完毕后，每执行一个新的写命令就再发送一次 5.接收并执行每一个写命令 hash算法及数据库实现 把任意长度的输入，通过hash算法变成固定长度的输出，输出的值就是hash的值。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://zfd.github.io/categories/笔记/"}],"tags":[{"name":"php","slug":"php","permalink":"https://zfd.github.io/tags/php/"},{"name":"note","slug":"note","permalink":"https://zfd.github.io/tags/note/"}]},{"title":"设计模式","slug":"设计模式/设计模式","date":"2018-02-24T16:42:42.000Z","updated":"2018-05-22T09:48:48.000Z","comments":true,"path":"2018/02/25/设计模式/设计模式/","link":"","permalink":"https://zfd.github.io/2018/02/25/设计模式/设计模式/","excerpt":"","text":"设计模式的理解：代码设计经验的总结。设计模式的作用：降低代码耦合度，提高代码重用性、可读性、可靠性。 单例模式主要作用在整个项目中创建唯一对象实例。 适用场景如：数据库连接。 实现方法 $_instance必须声明为静态的私有变量。 构造函数和析构函数必须声明为私有，防止外部程序new。 私有的__clone()方法防止克隆对象。 getInstance()方法必须设置为公有的，必须调用此方法以返回实例的一个引用。 代码demo123456789101112131415161718192021222324252627282930313233343536&lt;?php class Singleton &#123; private static $instance; //私有构造方法，禁止使用new创建对象 private function __construct() &#123;&#125; //私有析构方法 private function __destruct() &#123;&#125; //将克隆方法设为私有，禁止克隆对象 private function __clone() &#123;&#125; public static function getInstance() &#123; if (!isset(self::$instance)) &#123; self::$instance = new self; &#125; return self::$instance; &#125; public function say() &#123; echo \"这是用单例模式创建对象实例\\n\"; &#125; public function operation() &#123; echo \"这里可以添加其他方法和操作\\n\"; &#125;&#125;$objSingle = Singleton::getInstance();$objSingle-&gt;say();$objSingle-&gt;operation(); $objSingleNew = Singleton::getInstance();var_dump($shiyanlou === $objSingleNew); 简单工厂模式优缺点优点： 外界仅需要使用这个对象即可，不必关系创建。 避免改变某个类的名字或者方法之后，在调用这个类的所有的代码中都修改它的名字或者参数。 缺点： 产品类不断增多的时候，工厂类的条件判断逻辑增多，不利于维护、拓展。 适用场景 工厂类负责创建的对象比较少。 客户只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心。 由于简单工厂很容易违反高内聚责任分配原则，因此一般只在很简单的情况下应用。 实现方法 工厂方法或者类生成对象，而不是在代码中直接new。 代码demo123456789101112131415161718192021222324252627&lt;?php //简单工厂模式class Cat &#123; function __construct() &#123; echo \"I am Cat class &lt;br&gt;\"; &#125;&#125;class Dog &#123; function __construct() &#123; echo \"I am Dog class &lt;br&gt;\"; &#125;&#125;class Factory &#123; public static function CreateAnimal($name)&#123; if ($name == 'cat') &#123; return new Cat(); &#125; elseif ($name == 'dog') &#123; return new Dog(); &#125; &#125;&#125;$cat = Factory::CreateAnimal('cat');$dog = Factory::CreateAnimal('dog'); 注册模式主要作用解决全局共享和交换对象。 实现方法 将对象注册到全局静态变量。 任何地方直接去访问。 代码demo12345678910111213141516&lt;?phpclass Register &#123; protected static $objects; public function set($alias,$object) &#123; self::$objects[$alias] = $object; &#125; public static function get($name) &#123; return self::$objects[$name]; &#125; public function _unset($alias) &#123; unset(self::$objects[$alias]); &#125;&#125; 适配器模式 区别于策略模式，不改变已有类的方法，通过一套接口把已有类的方法统一成一样的api。选择了一个适配器就从头用到尾，中途不能更改。 主要作用将一个类的接口适配成用户所期待的。 适用场景想使用一个已经存在的类，但是他的接口并不符合要求。如： PHP中的数据库操作有MySQL，MySQLi，PDO三种，可以用适配器模式统一成一致，使不同的数据库操作，统一成一样的API。 可以将memcache,redis等不同的缓存函数适配成统一的API。 实现方法 首先定义一个接口（有几个方法，以及相应的参数）。 有几种不同的情况，就写几个类实现该接口。 代码demo接口 12345678//IDatabase&lt;?phpnamespace IMooc;interface IDatabase &#123; function connect($host, $user, $passwd, $dbname); function query($sql); function close();&#125; 适配器类（实现目标接口） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162MySQL&lt;?phpnamespace IMooc\\Database;use IMooc\\IDatabase;class MySQL implements IDatabase &#123; protected $conn; function connect($host, $user, $passwd, $dbname) &#123; $conn = mysql_connect($host, $user, $passwd); mysql_select_db($dbname, $conn); $this-&gt;conn = $conn; &#125; function query($sql) &#123; $res = mysql_query($sql, $this-&gt;conn); return $res; &#125; function close() &#123; mysql_close($this-&gt;conn); &#125;&#125;MySQLi&lt;?phpnamespace IMooc\\Database;use IMooc\\IDatabase;class MySQLi implements IDatabase &#123; protected $conn; function connect($host, $user, $passwd, $dbname) &#123; $conn = mysqli_connect($host, $user, $passwd, $dbname); $this-&gt;conn = $conn; &#125; function query($sql) &#123; return mysqli_query($this-&gt;conn, $sql); &#125; function close() &#123; mysqli_close($this-&gt;conn); &#125;&#125;PDO&lt;?phpnamespace IMooc\\Database;use IMooc\\IDatabase;class PDO implements IDatabase &#123; protected $conn; function connect($host, $user, $passwd, $dbname) &#123; $conn = new \\PDO(\"mysql:host=$host;dbname=$dbname\", $user, $passwd); $this-&gt;conn = $conn; &#125; function query($sql) &#123; return $this-&gt;conn-&gt;query($sql); &#125; function close() &#123; unset($this-&gt;conn); &#125;&#125; 使用 12IDatabase mAdapter = new PDO();//MySQL MySQLi PDOmAdapter.connect(...); 策略模式 区别于适配模式，类的方法都是新实现的，并且可以相互替换。 主要作用定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。 适用场景 多个类只区别在表现行为不同，可以使用Strategy模式，在运行时动态选择具体要执行的行为。 需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。 实现方法 首先定义一个接口（有几个方法，以及相应的参数）。 有几种不同的情况，就写几个类实现该接口。 实现一个环境类，可以根据实际情况选择、切换策略。 代码demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?php/** *策略模式 *定义一系列的算法，把每一个算法封装起来，并且使它们可相互替换。 *本模式使得算法可独立于使用它的客户变化 *//** *出行旅游 */interface TravelStrategy &#123; public function travelAlgorithm();&#125;/** *具体策略类(ConcreteStrategy) *1：乘坐飞机 */class AirPlanelStrategy implements TravelStrategy &#123; public function travelAlgorithm() &#123; echo \"travelbyAirPlain\", \"\\n\"; &#125;&#125;/** *具体策略类(ConcreteStrategy) *2：乘坐火车 */class TrainStrategy implements TravelStrategy &#123; public function travelAlgorithm() &#123; echo \"travelbyTrain\", \"\\n\"; &#125;&#125;/** *具体策略类(ConcreteStrategy) *3：骑自行车 */class BicycleStrategy implements TravelStrategy &#123; public function travelAlgorithm() &#123; echo \"travelbyBicycle\", \"\\n\"; &#125;&#125;/** * *环境类(Context): *用一个ConcreteStrategy对象来配置。 *维护一个对Strategy对象的引用。可定义一个接口来让Strategy访问它的数据。 *算法解决类，以提供客户选择使用何种解决方案： */class PersonContext &#123; private $_strategy = null; public function __construct(TravelStrategy $travel) &#123; $this-&gt;_strategy = $travel; &#125; /** *旅行 */ public function setTravelStrategy(TravelStrategy $travel) &#123; $this-&gt;_strategy = $travel; &#125; /** *旅行 */ public function travel() &#123; return $this-&gt;_strategy-&gt;travelAlgorithm(); &#125;&#125;//乘坐火车旅行$person = new PersonContext(new TrainStrategy());$person-&gt;travel();//改骑自行车$person-&gt;setTravelStrategy(new BicycleStrategy());$person-&gt;travel(); 观察者模式 观察者模式(Observer)，当一个对象状态发生变化时，依赖它的对象全部会收到通知，并自动更新。 优缺点优点：观察者和主题之间的耦合度较小；支持广播通信； 缺点：由于观察者并不知道其它观察者的存在，它可能对改变目标的最终代价一无所知。这可能会引起意外的更新。 适用场景 一个事件发生后，要执行一连串更新操作。传统的编程方式，就是在事件的代码之后直接加入处理的逻辑。当更新的逻辑增多之后，代码会变得难以维护。这种方式是耦合的，侵入式的，增加新的逻辑需要修改事件的主体代码。 观察者模式实现了低耦合，非侵入式的通知与更新机制。 代码demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;?php/** * 观察者模式 *//** * 抽象主题角色 */interface Subject &#123; /** * 增加一个新的观察者对象 * @param Observer $observer */ public function attach(Observer $observer); /** * 删除一个已注册过的观察者对象 * @param Observer $observer */ public function detach(Observer $observer); /** * 通知所有注册过的观察者对象 */ public function notifyObservers();&#125;/** * 具体主题角色 */class ConcreteSubject implements Subject &#123; private $_observers; public function __construct() &#123; $this-&gt;_observers = array(); &#125; //增加一个新的观察者对象 public function attach(Observer $observer) &#123; return array_push($this-&gt;_observers, $observer); &#125; //删除一个已注册过的观察者对象 public function detach(Observer $observer) &#123; $index = array_search($observer, $this-&gt;_observers); if ($index === FALSE || ! array_key_exists($index, $this-&gt;_observers)) &#123; return FALSE; &#125; unset($this-&gt;_observers[$index]); return TRUE; &#125; //通知所有注册过的观察者对象 public function notifyObservers() &#123; if (!is_array($this-&gt;_observers)) &#123; return FALSE; &#125; foreach ($this-&gt;_observers as $observer) &#123; $observer-&gt;update(); &#125; return TRUE; &#125;&#125;/** * 抽象观察者角色 */interface Observer &#123; /** * 更新方法 */ public function update();&#125;class ConcreteObserver implements Observer &#123; //观察者的名称 private $_name; public function __construct($name) &#123; $this-&gt;_name = $name; &#125; //更新方法 public function update() &#123; echo 'Observer', $this-&gt;_name, \" has notified.\\n\"; &#125;&#125;//实例化类：$subject = new ConcreteSubject();/* 添加第一个观察者 */$observer1 = new ConcreteObserver('Martin');$subject-&gt;attach($observer1);echo \"\\n The First notify:\\n\";$subject-&gt;notifyObservers();/* 添加第二个观察者 */$observer2 = new ConcreteObserver('phppan');$subject-&gt;attach($observer2);echo \"\\n The Second notify:\\n\";$subject-&gt;notifyObservers();/* 删除第一个观察者 */$subject-&gt;detach($observer1);echo \"\\n The Third notify:\\n\";$subject-&gt;notifyObservers();","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://zfd.github.io/categories/设计模式/"}],"tags":[{"name":"php","slug":"php","permalink":"https://zfd.github.io/tags/php/"},{"name":"设计模式","slug":"设计模式","permalink":"https://zfd.github.io/tags/设计模式/"}]},{"title":"nginx、CGI、fastCGI、php-cgi、php-fpm","slug":"服务器/nginx、CGI、fastCGI、php-cgi、php-fpm","date":"2018-02-07T17:12:45.000Z","updated":"2018-05-22T09:48:48.000Z","comments":true,"path":"2018/02/08/服务器/nginx、CGI、fastCGI、php-cgi、php-fpm/","link":"","permalink":"https://zfd.github.io/2018/02/08/服务器/nginx、CGI、fastCGI、php-cgi、php-fpm/","excerpt":"","text":"名词解释 nginx：web server，内容分发者，只能处理静态文件，动态脚本只能交给php自己处理。 CGI：通用网关接口（common gateway interface），是 Web Server 与 Web Application 之间数据交换的一种协议。 FastCGI：同 CGI，是一种通信协议，但比 CGI 在效率上做了一些优化。同样，SCGI 协议与 FastCGI 类似。 PHP-CGI：是 PHP（Web Application）对 Web Server 提供的 CGI 协议的接口程序。 PHP-FPM：是 PHP（Web Application）对 Web Server 提供的 FastCGI 协议的接口程序，它直接管理多个 PHP-CGI 进程。 fastCGIfastCGI可以理解为一个常驻型的cgi，其主要行为是将CGI解释器进程保持在内存中，并因此获得较高的性能。 作用 解决cgi并发重复fork的问题； 支持分布式运算； php-fpm就是 php-cgi 的进程管理器，修改php.ini后，可以重新fork php-cgi进程，实现平滑重启。 运行模式 static：静态分配，启动时分配固定的worker进程； ondemand：按需分配，当收到用户请求时fork worker进程； dynamic：动态分配，启动时分配固定进程，用户请求增加，按照设定范围浮动； 运行原理一个master进程，管理多个worker进程； master进程： 初始化cgi； 初始化php环境； 初始化php-fpm； 运行，主进程fork子进程，主进程阻塞，事件循环； worker进程： 接收请求； 处理请求； 返回请求结果； nginx，php-fpm工作流程12345678910111213141516171819202122232425 www.example.com | | Nginx | |路由到www.example.com/index.php | |加载nginx的fast-cgi模块 | |www.example.com/index.php请求到达127.0.0.1:9000（fast-cgi协议） | |php-fpm 监听127.0.0.1:9000 | |php-fpm 接收到请求，启用worker进程处理请求 | |php-fpm 处理完请求，返回给nginx | |nginx将结果通过http返回给浏览器","categories":[{"name":"服务器","slug":"服务器","permalink":"https://zfd.github.io/categories/服务器/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://zfd.github.io/tags/nginx/"},{"name":"CGI","slug":"CGI","permalink":"https://zfd.github.io/tags/CGI/"},{"name":"fastCGI","slug":"fastCGI","permalink":"https://zfd.github.io/tags/fastCGI/"},{"name":"php-fpm","slug":"php-fpm","permalink":"https://zfd.github.io/tags/php-fpm/"}]},{"title":"代理","slug":"服务器/代理","date":"2018-02-03T17:53:20.000Z","updated":"2018-05-22T09:48:48.000Z","comments":true,"path":"2018/02/04/服务器/代理/","link":"","permalink":"https://zfd.github.io/2018/02/04/服务器/代理/","excerpt":"","text":"正向代理概念（正向）代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。 1client -&gt; 正向代理 -&gt; internet -&gt; server 作用 访问原来无法访问的资源，如google 可以做缓存，加速访问资源 对客户端访问授权，上网进行认证 代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息 反向代理概念反向代理，是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 1client -&gt; internet -&gt; 反向代理 -&gt; servers 作用 可以缓存静态内容，当静态内容发生变化时，通过内部通知机制通知反向代理服务器缓存失效，需重新加载。 可以实现负载均衡。 总结“正向”，“反向”是相对于人的感知来说的。人能感受到的代理就是正向代理，人感受不到的代理就是反向代理。 正向代理，代理客户端；反向代理，代理服务器；","categories":[{"name":"服务器","slug":"服务器","permalink":"https://zfd.github.io/categories/服务器/"}],"tags":[{"name":"server","slug":"server","permalink":"https://zfd.github.io/tags/server/"},{"name":"proxy","slug":"proxy","permalink":"https://zfd.github.io/tags/proxy/"}]},{"title":"nginx高并发原理","slug":"服务器/nginx高并发原理","date":"2018-02-03T15:11:53.000Z","updated":"2018-05-22T09:48:48.000Z","comments":true,"path":"2018/02/03/服务器/nginx高并发原理/","link":"","permalink":"https://zfd.github.io/2018/02/03/服务器/nginx高并发原理/","excerpt":"","text":"Nginx 采用的是多进程 &amp;&amp; 多路IO复用模型。 多进程的工作模式 Nginx启动后，会有一个master进程和多个项目独立的worker进程。 master进程接收来自外界信号，然后向worker进程发送，每个进程都有可能处理这个连接。 master进程监控worker进程运行状态，worker进程异常退出时，启动新的进程。 注：worker进程数一般为cpu核数，因为更多的worker进程数会导致相互竞争cpu，从而带来不必要的上下文切换。 惊群现象 &amp;&amp; 解决方法现象：master进程创建一个sockfd（socket文件描述符），然后fork子进程，子进程继承父进程的sockfd，之后子进程accept后再创建已连接描述符，最后与客户端通信。由于，所有子进程都继承父进程的sockfd，当客户端连接进来时，所有子进程都会收到通知并抢着与他建立连接，这就叫惊群现象。大量的进程被激活又挂起，只有一个进程可以accept这个连接，当然会消耗系统资源。 处理：nginx提供一个accept_mutex，这是一个加在accept上的一把互斥锁。同一时刻只有一个子进程去accept，这里就不会有惊群问题了。 worker进程工作流程accept客户端的连接-&gt;读取请求-&gt;解析请求-&gt;处理请求-&gt;返回结果给客户端-&gt;断开连接。 一个请求，完全由一个worker进程处理，好处： 节省锁带来的开销；每个worker进程都是独立的进程，不共享资源，不需要加锁。 独立进程，减少风险，进程之间相互不会影响。 多路IO复用模型epollepoll通过在linux内核中申请一个简易的文件系统（数据结构：B+树），工作原理： 调用 int epoll_create(int size) 建立一个epoll对象，内核会创建一个eventpoll结构体，用于存放通过epoll_ctl()向epoll对象中添加进来的事件，这些事件都会挂载在红黑树中。 调用 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event) 在 epoll 对象中为 fd 注册事件，所有添加到epoll中的事件都会与设备驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个sockfd的回调方法，将sockfd添加到eventpoll 中的双链表。 调用 int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout) 来等待事件的发生，timeout 为 -1 时，该调用会阻塞知道有事件发生","categories":[{"name":"服务器","slug":"服务器","permalink":"https://zfd.github.io/categories/服务器/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://zfd.github.io/tags/nginx/"},{"name":"server","slug":"server","permalink":"https://zfd.github.io/tags/server/"},{"name":"epoll","slug":"epoll","permalink":"https://zfd.github.io/tags/epoll/"}]},{"title":"搭建博客","slug":"日常/搭建博客","date":"2018-01-30T11:53:15.000Z","updated":"2018-05-22T09:48:48.000Z","comments":true,"path":"2018/01/30/日常/搭建博客/","link":"","permalink":"https://zfd.github.io/2018/01/30/日常/搭建博客/","excerpt":"","text":"主要环境：nodeJs， git，hexo NodeJs安装：https://nodejs.org/en Git 安装：https://git-scm.com 生成公钥，供后面的github账号使用 123456789# 中括号为需要替换的内容 [你的用户名] =&gt; zfdgit config --global user.name [你的用户名]git config --global user.email [你的邮箱]ssh-keygen -t rsa -C [你的邮箱]# 进入&#123;home_dir&#125;/.sshcd cd .sshcat id_rsa.pub Github设置添加ssh keys主页-&gt;点击头像-&gt;setting-&gt;SSH keys-&gt;Add new，把上面的git本地公钥复制到key里面，写个title保存即可。添加认证后，hexo可以自动提交到github. 新建repo新建一个repo，注意名称一定是username.github.io这样的格式，默认访问url：https://username.github.io Hexo安装安装hexo：12npm install -g hexo-clinpm install -g hexo-server 进入项目目录，安装其他：1npm install 安装hexo-theme-indigo主题：https://github.com/yscoder/hexo-theme-indigo/wiki/%E5%AE%89%E8%A3%85 相关命令：https://hexo.io/zh-cn/docs/setup.html12hexo new page tagshexo new page categories 本地看效果：12hexo clean &amp;&amp; hexo ghexo server 提交github1hexo d 写作你可以执行下列命令来创建一篇新文章。您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。1hexo new [layout] &lt;title&gt; https://hexo.io/zh-cn/docs/writing.html 一键部署、提交设置git alias 1git config --global alias.blog '!hexo g &amp;&amp; hexo d &amp;&amp; git pull &amp;&amp; git add -A &amp;&amp; git commit -m \"blog update\" &amp;&amp; git push origin master' 一键提交2个github项目1git blog 注：第一次提交先单独push一次，会有账号密码验证。 最终成果blogServer project：https://github.com/zfd/blogServerblog project：https://github.com/zfd/zfd.github.ioblog url: https://zfd.github.io","categories":[{"name":"日常","slug":"日常","permalink":"https://zfd.github.io/categories/日常/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zfd.github.io/tags/hexo/"},{"name":"github pages","slug":"github-pages","permalink":"https://zfd.github.io/tags/github-pages/"}]},{"title":"Hello World","slug":"日常/hello-world","date":"2018-01-30T10:00:00.000Z","updated":"2018-05-22T09:48:48.000Z","comments":true,"path":"2018/01/30/日常/hello-world/","link":"","permalink":"https://zfd.github.io/2018/01/30/日常/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"日常","slug":"日常","permalink":"https://zfd.github.io/categories/日常/"}],"tags":[{"name":"test","slug":"test","permalink":"https://zfd.github.io/tags/test/"}]}]}